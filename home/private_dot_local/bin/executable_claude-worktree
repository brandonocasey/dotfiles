#!/bin/bash
set -e

# Configuration constants
readonly PORT_MIN=3000
readonly PORT_MAX=9000
readonly PORT_RETRY_COUNT=5

# Helper function to remove localias
remove_localias() {
    if command -v localias >/dev/null 2>&1; then
        local alias="${FEATURE_NAME}.local"
        if localias list | grep -q "$alias"; then
            echo "üîó Removing localias: $alias"
            localias remove "$alias"
        fi
    fi
}

# Print cleanup instructions
print_cleanup_instructions() {
    echo "üìÅ Worktree preserved at: $WORKTREE_DIR"
    echo "üåø Branch '$FEATURE_NAME' available for later work"
    echo "To clean up later: claude-worktree --clean '$FEATURE_NAME'"
}

# Auto-install dependencies based on detected package managers
install_dependencies() {
    # Define package managers with their detection files, commands, and emojis
    local yarn_lock="yarn.lock"
    local package_json="package.json"

    # Check for Node.js dependencies (prefer yarn over npm)
    if [ -f "$yarn_lock" ] && [ -f "$package_json" ] && command -v yarn >/dev/null 2>&1; then
        echo "üß∂ Installing yarn dependencies..."
        yarn install --frozen-lockfile
    elif [ -f "$package_json" ] && command -v npm >/dev/null 2>&1; then
        echo "üì¶ Installing npm dependencies..."
        npm ci 2>/dev/null || npm install
    fi

    # Check other package managers
    if [ -f "Cargo.toml" ] && command -v cargo >/dev/null 2>&1; then
        echo "ü¶Ä Building Rust project..."
        cargo build
    fi

    if [ -f "requirements.txt" ] && command -v pip >/dev/null 2>&1; then
        echo "üêç Installing Python dependencies..."
        pip install -r requirements.txt
    fi

    if [ -f "Gemfile" ] && command -v bundle >/dev/null 2>&1; then
        echo "üíé Installing Ruby dependencies..."
        bundle install
    fi
}

# Validate environment and initialize globals
setup_environment() {
    # Check if running in tmux
    if [ -z "$TMUX" ]; then
        echo "Error: This script must be run from within tmux"
        echo "Start tmux first: tmux new-session"
        exit 1
    fi

    # Get the current git directory
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: Not in a git repository"
        exit 1
    fi

    # Get the root of the git repository
    GIT_ROOT="$(git rev-parse --show-toplevel)"
    REPO_NAME="$(basename "$GIT_ROOT")"
    PARENT_DIR="$(dirname "$GIT_ROOT")"
    WORKTREE_DIR="${PARENT_DIR}/${REPO_NAME}-${FEATURE_NAME}"
}

# Create and setup the worktree environment
setup_worktree() {
    echo "üìÅ Creating worktree at: $WORKTREE_DIR"
    echo "üåø Branch: $FEATURE_NAME"
    git worktree add "$WORKTREE_DIR" -b "$FEATURE_NAME" 2>/dev/null || git worktree add "$WORKTREE_DIR" "$FEATURE_NAME"

    # Change to worktree directory
    echo "üìÇ Switching to worktree directory..."
    cd "$WORKTREE_DIR"

    # Auto-install dependencies
    install_dependencies
}

# Save environment variables to worktree directory
save_env_variables() {
    local env_file="$WORKTREE_DIR/.claude-worktree.local.env"
    echo "üíæ Saving environment variables to $env_file"
    
    cat > "$env_file" << EOF
# Claude-worktree environment variables
# Generated on $(date)
export PORT="$PORT"
export __VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS="$__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS"
EOF
}

# Load environment variables from worktree directory
load_env_variables() {
    local env_file="$WORKTREE_DIR/.claude-worktree.local.env"
    
    if [ -f "$env_file" ]; then
        echo "üìÇ Loading saved environment variables from $env_file"
        # Source the file to load variables
        . "$env_file"
        echo "üì° Restored development server port: $PORT"
        if [ -n "$__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS" ]; then
            echo "üåê Restored local alias: https://$__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS"
        fi
    fi
}

# Setup localias with random port
setup_localias() {
    if ! command -v localias >/dev/null 2>&1; then
        echo "‚ö†Ô∏è  localias not found, skipping local alias setup"
        echo "   Install with: go install github.com/peterldowns/localias@latest"
        return
    fi

    # Generate random port between PORT_MIN-PORT_MAX
    PORT=$((PORT_MIN + RANDOM % (PORT_MAX - PORT_MIN)))

    # Check if port is already in use, try a few times
    for i in $(seq 1 $PORT_RETRY_COUNT); do
        if ! lsof -i :$PORT >/dev/null 2>&1; then
            break
        fi
        PORT=$((PORT_MIN + RANDOM % (PORT_MAX - PORT_MIN)))
    done

    ALIAS="${FEATURE_NAME}.local"
    echo "üîó Setting up localias: $ALIAS -> localhost:$PORT"

    # Check if localias daemon is running, start if needed
    local daemon_was_stopped=false
    if ! localias status >/dev/null 2>&1; then
        echo "  Running: localias start"
        localias start >/dev/null 2>&1 || true
        daemon_was_stopped=true
    else
        echo "  Localias daemon already running"
    fi

    # Set the alias
    echo "  Running: localias set $ALIAS $PORT"
    localias set "$ALIAS" "$PORT" >/dev/null 2>&1

    # Reload daemon if it was just started to pick up the new alias
    if [ "$daemon_was_stopped" = true ]; then
        echo "  Running: localias reload"
        localias reload >/dev/null 2>&1 || true
    fi

    # Export environment variables for development
    export PORT
    export __VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS="$ALIAS"
    echo "üì° Development server port: $PORT"
    echo "üåê Local alias: https://$ALIAS"
    
    # Save environment variables for --continue mode
    save_env_variables
}

# Run Claude with optional initial prompt
run_claude_session() {
    # Check for initial prompt file
    local initial_prompt=""
    if [ -f "./scripts/claude-worktree-initial-prompt" ]; then
        echo "üìù Using initial prompt from ./scripts/claude-worktree-initial-prompt"
        initial_prompt=$(cat "./scripts/claude-worktree-initial-prompt")
    fi

    if ! claude "$initial_prompt"; then
        handle_claude_exit
    fi

    # Kill processes after Claude exits
    kill_worktree_processes

    echo ""
    echo "‚úÖ Claude session completed."
}

# Handle Claude exit (error or interruption)
handle_claude_exit() {
    echo ""
    echo "‚ö†Ô∏è  Claude exited with an error or was interrupted."

    # Always kill processes after Claude exits
    kill_worktree_processes

    if prompt_yes_no "Do you want to remove the worktree still? (y/N): " "n"; then
        perform_cleanup
        exit 0
    else
        print_cleanup_instructions
        exit 0
    fi
}

# Switch to main/master branch
switch_to_main_branch() {
    local current_branch
    current_branch=$(git symbolic-ref --short HEAD)
    if [ "$current_branch" != "main" ] && [ "$current_branch" != "master" ]; then
        git checkout main 2>/dev/null || git checkout master 2>/dev/null || {
            echo "Error: Could not switch to main/master branch"
            exit 1
        }
    fi
}

# Remove branch with force delete
remove_branch() {
    if git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
        echo "üåø Removing branch: $FEATURE_NAME"
        git branch -D "$FEATURE_NAME" 2>/dev/null || {
            echo "Warning: Could not remove branch '$FEATURE_NAME'"
        }
    fi
}

# Get merge preference from user
get_merge_preference() {
    while true; do
        printf "Merge branch '$FEATURE_NAME' into main? (Y=merge, s=squash, n=no): "
        read -r merge_response

        case "$merge_response" in
        [yY] | [yY][eE][sS] | "")
            merge_type="merge"
            break
            ;;
        [sS] | [sS][qQ][uU][aA][sS][hH])
            merge_type="squash"
            break
            ;;
        [nN] | [nN][oO])
            merge_type="no"
            break
            ;;
        *)
            echo "Please answer Y (merge), s (squash), or n (no)"
            ;;
        esac
    done
}

# Execute merge operation based on merge_type
execute_merge() {
    # Go back to original repo to merge
    cd "$GIT_ROOT"
    switch_to_main_branch

    if [ "$merge_type" = "squash" ]; then
        echo "üîÑ Squash merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --squash "$FEATURE_NAME"; then
            # Commit the squashed changes (opens editor)
            if git commit; then
                echo "‚úÖ Squash merge successful!"
                merge_successful=true
            else
                echo "Commit cancelled or failed."
                print_cleanup_instructions
                exit 1
            fi
        else
            echo "Squash merge conflicts detected. Please resolve them manually."
            print_cleanup_instructions
            exit 1
        fi
    else
        echo "üîÄ Merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --no-edit "$FEATURE_NAME"; then
            echo "‚úÖ Merge successful!"
            merge_successful=true
        else
            echo "Merge conflicts detected. Please resolve them manually."
            print_cleanup_instructions
            exit 1
        fi
    fi

    # Push to remote
    if [ "$merge_successful" = true ]; then
        echo "üöÄ Pushing to remote..."
        current_branch=$(git symbolic-ref --short HEAD)
        git push
    fi
}

# Execute continue operation (resume Claude session)
execute_continue_operation() {
    echo "üîÑ Continue mode: resuming Claude session for feature '$FEATURE_NAME'"

    # Validate that worktree/branch exists
    validate_existing_feature

    # Change to worktree directory
    echo "üìÇ Switching to existing worktree directory..."
    cd "$WORKTREE_DIR"

    # Load saved environment variables
    load_env_variables

    # Optionally re-setup localias if variables were loaded
    if [ -n "$PORT" ] && [ -n "$__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS" ]; then
        # Extract feature name from the alias
        local saved_alias="$__VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS"
        if command -v localias >/dev/null 2>&1; then
            echo "üîó Re-establishing localias: $saved_alias -> localhost:$PORT"
            # Ensure daemon is running
            if ! localias status >/dev/null 2>&1; then
                echo "  Running: localias start"
                localias start >/dev/null 2>&1 || true
            fi
            # Set the alias again
            localias set "$saved_alias" "$PORT" >/dev/null 2>&1
        fi
    fi

    # Launch Claude with --continue (skip initial prompt)
    echo "üöÄ Resuming Claude session with --continue..."
    if ! claude --continue; then
        handle_claude_exit
    fi

    # Kill processes after Claude exits
    kill_worktree_processes

    # Post-Claude processing
    echo ""
    echo "‚úÖ Claude session completed."

    # Handle merge and cleanup
    handle_merge_and_cleanup
}

# Execute merge operation (skip to merge and cleanup)
execute_merge_operation() {
    echo "üîÄ Merge mode: skipping to merge and cleanup for feature '$FEATURE_NAME'"

    # Validate that worktree/branch exists
    validate_existing_feature

    # Kill any processes that might be running
    kill_worktree_processes

    # Jump to post-Claude processing (merge and cleanup logic)
    echo ""
    echo "‚úÖ Starting merge process for feature '$FEATURE_NAME'"

    # Handle merge and cleanup
    handle_merge_and_cleanup
}

# Execute clean operation (remove worktree and branch)
execute_clean_operation() {
    echo "üßπ Cleaning up feature: $FEATURE_NAME"
    perform_cleanup
    echo "‚úÖ Cleanup complete!"
}

# Handle existing feature detection and user choice
handle_existing_feature() {
    echo "‚ö†Ô∏è  A worktree for '$FEATURE_NAME' already exists at: $WORKTREE_DIR"
    echo ""
    echo "What would you like to do?"
    echo "  1. Continue working on the feature (resume Claude session)"
    echo "  2. Merge and cleanup the feature"
    echo "  3. Clean up the feature (remove worktree and branch)"
    echo "  4. Cancel (preserve existing worktree)"
    echo ""

    while true; do
        printf "Choose an option (1-4): "
        read -r choice

        case "$choice" in
        1)
            execute_continue_operation
            exit 0
            ;;
        2)
            execute_merge_operation
            exit 0
            ;;
        3)
            execute_clean_operation
            exit 0
            ;;
        4)
            echo "‚ùå Cancelled - existing worktree preserved at: $WORKTREE_DIR"
            print_cleanup_instructions
            exit 0
            ;;
        *)
            echo "Invalid choice. Please enter 1, 2, 3, or 4."
            ;;
        esac
    done
}

# Handle merge and cleanup flow
handle_merge_and_cleanup() {
    # Get merge preference from user
    get_merge_preference

    if [ "$merge_type" != "no" ]; then
        # Execute the merge
        execute_merge

        # Clean up worktree and branch after merge
        perform_cleanup
    else
        echo "Skipping merge."

        # Ask about cleanup only if no merge
        if prompt_yes_no "Do you want to delete the worktree and branch '$FEATURE_NAME'? (y/N): " "n"; then
            perform_cleanup
        else
            echo "To merge later: git merge '$FEATURE_NAME'"
            print_cleanup_instructions
        fi
    fi
}

# Validate that worktree and branch exist for modes that require them
validate_existing_feature() {
    # Skip if we've already validated
    if [ "$FEATURE_VALIDATED" = true ]; then
        return
    fi

    # Check if worktree exists
    if [ ! -d "$WORKTREE_DIR" ] && ! git worktree list | grep -q "$WORKTREE_DIR"; then
        echo "Error: No worktree found for feature '$FEATURE_NAME' at: $WORKTREE_DIR"
        exit 1
    fi

    # Check if branch exists
    if ! git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
        echo "Error: Branch '$FEATURE_NAME' does not exist"
        exit 1
    fi

    # Mark as validated
    FEATURE_VALIDATED=true
}

# Generic yes/no prompt handler
prompt_yes_no() {
    local prompt="$1"
    local default="$2" # "y" or "n"

    while true; do
        printf "%s" "$prompt"
        read -r response

        case "$response" in
        [yY] | [yY][eE][sS])
            return 0 # yes
            ;;
        [nN] | [nN][oO])
            return 1 # no
            ;;
        "")
            if [ "$default" = "y" ]; then
                return 0
            else
                return 1
            fi
            ;;
        *)
            echo "Please answer y(es) or n(o)"
            ;;
        esac
    done
}

# Unified cleanup function - always forces removal but asks about uncommitted changes
perform_cleanup() {
    echo "üßπ Cleaning up feature: $FEATURE_NAME"

    cd "$GIT_ROOT"

    # Kill any processes running in the worktree directory first
    kill_worktree_processes

    # Remove localias
    remove_localias

    # Verify worktree exists before attempting cleanup
    if [ ! -d "$WORKTREE_DIR" ] && ! git worktree list | grep -q "$WORKTREE_DIR"; then
        echo "No worktree found for '$FEATURE_NAME' - nothing to clean up"
    else
        # Check for uncommitted changes
        if ! git -C "$WORKTREE_DIR" diff --quiet || ! git -C "$WORKTREE_DIR" diff --cached --quiet || [ -n "$(git -C "$WORKTREE_DIR" ls-files --others --exclude-standard)" ]; then
            echo "Warning: The worktree has unstaged changes, staged changes, or untracked files."
            git status --short

            # Ask user for confirmation before proceeding
            if prompt_yes_no "Force remove the worktree anyway? (y/N): " "n"; then
                echo "Proceeding with removal of uncommitted changes..."
            else
                print_cleanup_instructions
                exit 0
            fi
        fi

        # Remove worktree (always remove if we reach here)
        echo "üßπ Removing worktree at '$WORKTREE_DIR'..."
        git worktree remove --force "$WORKTREE_DIR"
    fi

    # Remove branch
    remove_branch

    echo "‚ú® Cleanup complete!"
}

# Parse command line arguments
parse_arguments() {
    CLEAN_MODE=false
    MERGE_MODE=false
    CONTINUE_MODE=false
    FEATURE_NAME=""

    while [ $# -gt 0 ]; do
        case $1 in
        -h | --help)
            echo "Usage: $0 <feature-name>"
            echo "       $0 --clean <feature-name>"
            echo "       $0 --merge <feature-name>"
            echo "       $0 --continue <feature-name>"
            echo ""
            echo "Creates a git worktree for feature development with Claude"
            echo ""
            echo "Arguments:"
            echo "  feature-name    Name of the feature branch to create/clean"
            echo ""
            echo "Options:"
            echo "  -h, --help     Show this help message"
            echo "  --clean        Remove worktree, branch, and localias for feature"
            echo "  --merge        Skip to merge and cleanup (as if Claude just exited)"
            echo "  --continue     Resume Claude session in existing worktree"
            echo ""
            echo "The script will:"
            echo "  1. Create a worktree in a sibling directory"
            echo "  2. Create or checkout the feature branch"
            echo "  3. Install dependencies if package files are found"
            echo "  4. Set up localias with random port (<feature>.local)"
            echo "  5. Set terminal/window title"
            echo "  6. Launch Claude"
            echo "  7. After Claude exits, offer to merge and cleanup"
            exit 0
            ;;
        --clean)
            CLEAN_MODE=true
            shift
            ;;
        --merge)
            MERGE_MODE=true
            shift
            ;;
        --continue)
            CONTINUE_MODE=true
            shift
            ;;
        -*)
            echo "Unknown option: $1"
            echo "Use -h or --help for more information"
            exit 1
            ;;
        *)
            if [ -z "$FEATURE_NAME" ]; then
                FEATURE_NAME="$1"
            else
                echo "Too many arguments"
                echo "Use -h or --help for more information"
                exit 1
            fi
            shift
            ;;
        esac
    done

    # Check if feature name is provided
    if [ -z "$FEATURE_NAME" ]; then
        echo "Usage: $0 <feature-name>"
        echo "       $0 --clean <feature-name>"
        echo "       $0 --merge <feature-name>"
        echo "       $0 --continue <feature-name>"
        echo "Use -h or --help for more information"
        exit 1
    fi
}

# Kill all processes in worktree directory except claude-worktree script
kill_worktree_processes() {
    # Skip if we've already killed processes
    if [ "$PROCESSES_KILLED" = true ]; then
        return
    fi

    if [ ! -d "$WORKTREE_DIR" ]; then
        return
    fi

    echo "üî™ Killing processes in worktree directory..."
    PROCESSES_KILLED=true

    # Get our script info for exclusion
    script_pid=$$
    script_name=$(basename "$0")

    # Get all processes using files in the worktree directory
    pids=$(lsof +D "$WORKTREE_DIR" 2>/dev/null | awk 'NR>1 {print $2}' | sort -u)

    for pid in $pids; do
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            # Skip our own process
            if [ "$pid" = "$script_pid" ]; then
                echo "  Skipping claude-worktree script (PID $pid)"
                continue
            fi

            # Get process info
            process_cmd=$(ps -p "$pid" -o args= 2>/dev/null || echo "unknown")

            # Skip if it's claude-worktree related
            case "$process_cmd" in
            *"claude-worktree"* | *"$script_name"*)
                echo "  Skipping claude-worktree process $pid: $process_cmd"
                continue
                ;;
            esac

            process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unknown")

            # Skip unknown processes for safety
            if [ "$process_name" = "unknown" ]; then
                echo "  Skipping unknown process $pid"
                continue
            fi

            echo "  Killing process $pid ($process_name): $process_cmd"
            kill "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null
        fi
    done
}

# Global variables - set during script execution
FEATURE_NAME=""         # Name of the feature branch being worked on
WORKTREE_DIR=""         # Path to the worktree directory
GIT_ROOT=""             # Root directory of the git repository
REPO_NAME=""            # Name of the repository
PARENT_DIR=""           # Parent directory containing the repository
CLEAN_MODE=false        # Whether script is running in cleanup mode
MERGE_MODE=false        # Whether script is running in merge mode
CONTINUE_MODE=false     # Whether script is running in continue mode
PROCESSES_KILLED=false  # Whether we've already killed worktree processes
FEATURE_VALIDATED=false # Whether we've already validated the existing feature

# Main execution function
main() {
    # Parse arguments and validate environment
    parse_arguments "$@"
    setup_environment

    # Handle clean mode if requested (exit early)
    if [ "$CLEAN_MODE" = true ]; then
        execute_clean_operation
        exit 0
    fi

    # Handle merge mode if requested (skip to merge and cleanup logic)
    if [ "$MERGE_MODE" = true ]; then
        execute_merge_operation
        exit 0
    fi

    # Handle continue mode if requested (resume Claude in existing worktree)
    if [ "$CONTINUE_MODE" = true ]; then
        execute_continue_operation
        exit 0
    fi

    # Check for existing worktree before creating
    if [ -d "$WORKTREE_DIR" ] || git worktree list | grep -q "$WORKTREE_DIR"; then
        # Validate that the existing feature is complete (worktree and branch exist)
        if git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
            handle_existing_feature
        else
            # Worktree exists but branch is missing - offer cleanup only
            echo "‚ö†Ô∏è  A worktree exists at '$WORKTREE_DIR' but branch '$FEATURE_NAME' is missing."
            if prompt_yes_no "Clean up the incomplete worktree? (Y/n): " "y"; then
                echo "üßπ Cleaning up incomplete worktree..."
                perform_cleanup
                echo "‚úÖ Incomplete worktree cleaned up"
            else
                echo "‚ùå Cancelled - incomplete worktree preserved"
                exit 0
            fi
        fi
    fi

    # Create worktree and setup environment
    setup_worktree
    setup_localias

    # Run Claude session
    run_claude_session

    # Handle merge and cleanup
    handle_merge_and_cleanup
}

# Execute main function with all arguments
main "$@"
