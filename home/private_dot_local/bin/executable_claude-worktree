#!/bin/sh
set -e

# Configuration constants
readonly PORT_MIN=3000
readonly PORT_MAX=9000
readonly PORT_RETRY_COUNT=5

# Helper function to remove localias
remove_localias() {
    if command -v localias >/dev/null 2>&1; then
        local alias="${FEATURE_NAME}.local"
        if localias list | grep -q "$alias"; then
            echo "üîó Removing localias: $alias"
            localias remove "$alias"
        fi
    fi
}

# Generic yes/no prompt handler
prompt_yes_no() {
    local prompt="$1"
    local default="$2"  # "y" or "n"
    
    while true; do
        printf "%s" "$prompt"
        read -r response
        
        case "$response" in
        [yY] | [yY][eE][sS])
            return 0  # yes
            ;;
        [nN] | [nN][oO])
            return 1  # no
            ;;
        "")
            if [ "$default" = "y" ]; then
                return 0
            else
                return 1
            fi
            ;;
        *)
            echo "Please answer y(es) or n(o)"
            ;;
        esac
    done
}

# Switch to main or master branch
switch_to_main_branch() {
    local current_branch
    current_branch=$(git symbolic-ref --short HEAD)
    if [ "$current_branch" != "main" ] && [ "$current_branch" != "master" ]; then
        # Try to switch to main, fall back to master
        git checkout main 2>/dev/null || git checkout master 2>/dev/null || {
            echo "Error: Could not switch to main/master branch"
            exit 1
        }
    fi
}

# Check for worktree changes and handle force removal
check_and_handle_worktree_changes() {
    cd "$WORKTREE_DIR"
    if ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
        echo "Warning: The worktree has unstaged changes, staged changes, or untracked files."
        git status --short
        
        if prompt_yes_no "Force remove the worktree anyway? (y/N): " "n"; then
            force_remove=true
        else
            echo "Worktree preserved at: $WORKTREE_DIR"
            echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
            exit 0
        fi
    fi
}

# Remove worktree and branch
remove_worktree_and_branch() {
    local force="$1"
    
    # Remove the worktree first (required before branch deletion)
    echo "üßπ Removing worktree at '$WORKTREE_DIR'..."
    if [ "$force" = "true" ]; then
        git worktree remove --force "$WORKTREE_DIR"
    else
        git worktree remove "$WORKTREE_DIR"
    fi

    # Delete the branch after worktree is removed
    echo "üóëÔ∏è  Deleting branch '$FEATURE_NAME'..."
    git branch -d "$FEATURE_NAME" 2>/dev/null || git branch -D "$FEATURE_NAME"
}

# Unified cleanup function
perform_cleanup() {
    local check_changes="$1"  # "true" to check for changes, "false" to skip
    
    # Check for changes if requested
    force_remove=false
    if [ "$check_changes" = "true" ]; then
        check_and_handle_worktree_changes
    fi

    # Go back to original repo for cleanup
    cd "$GIT_ROOT"

    # Remove localias
    remove_localias

    # Remove worktree and branch
    remove_worktree_and_branch "$force_remove"

    echo "‚ú® Cleanup complete!"
}

# Show help message
show_help() {
    echo "Usage: $0 <feature-name>"
    echo "       $0 --clean <feature-name>"
    echo ""
    echo "Creates a git worktree for feature development with Claude"
    echo ""
    echo "Arguments:"
    echo "  feature-name    Name of the feature branch to create/clean"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  --clean        Remove worktree, branch, and localias for feature"
    echo ""
    echo "The script will:"
    echo "  1. Create a worktree in a sibling directory"
    echo "  2. Create or checkout the feature branch"
    echo "  3. Install dependencies if package files are found"
    echo "  4. Set up localias with random port (<feature>.local)"
    echo "  5. Set terminal/window title"
    echo "  6. Launch Claude"
    echo "  7. After Claude exits, offer to merge and cleanup"
}

# Parse command line arguments
parse_arguments() {
    CLEAN_MODE=false
    FEATURE_NAME=""

    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            --clean)
                CLEAN_MODE=true
                shift
                ;;
            -*)
                echo "Unknown option: $1"
                echo "Use -h or --help for more information"
                exit 1
                ;;
            *)
                if [ -z "$FEATURE_NAME" ]; then
                    FEATURE_NAME="$1"
                else
                    echo "Too many arguments"
                    echo "Use -h or --help for more information"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Check if feature name is provided
    if [ -z "$FEATURE_NAME" ]; then
        echo "Usage: $0 <feature-name>"
        echo "       $0 --clean <feature-name>"
        echo "Use -h or --help for more information"
        exit 1
    fi
}

# Validate environment and git repository
validate_environment() {
    # Check if running in tmux
    if [ -z "$TMUX" ]; then
        echo "Error: This script must be run from within tmux"
        echo "Start tmux first: tmux new-session"
        exit 1
    fi

    # Get the current git directory
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: Not in a git repository"
        exit 1
    fi

    # Get the root of the git repository
    GIT_ROOT="$(git rev-parse --show-toplevel)"
    REPO_NAME="$(basename "$GIT_ROOT")"
    PARENT_DIR="$(dirname "$GIT_ROOT")"

    # Create worktree directory path
    WORKTREE_DIR="${PARENT_DIR}/${REPO_NAME}-${FEATURE_NAME}"
}

# Handle clean mode cleanup
handle_clean_mode() {
    echo "üßπ Cleaning up feature: $FEATURE_NAME"
    
    # Kill any processes running in the worktree directory first
    kill_worktree_processes
    
    # Remove localias
    remove_localias
    
    # Remove worktree if it exists
    if [ -d "$WORKTREE_DIR" ]; then
        echo "üìÅ Removing worktree: $WORKTREE_DIR"
        git worktree remove --force "$WORKTREE_DIR" 2>/dev/null || {
            echo "Warning: Could not remove worktree automatically"
            echo "You may need to remove it manually: rm -rf '$WORKTREE_DIR'"
        }
    fi
    
    # Remove branch if it exists
    if git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
        echo "üåø Removing branch: $FEATURE_NAME"
        git branch -D "$FEATURE_NAME" 2>/dev/null || {
            echo "Warning: Could not remove branch '$FEATURE_NAME'"
        }
    fi
    
    echo "‚ú® Cleanup complete for feature: $FEATURE_NAME"
}

# Create and setup worktree
create_worktree() {
    echo "üìÅ Creating worktree at: $WORKTREE_DIR"
    echo "üåø Branch: $FEATURE_NAME"
    git worktree add "$WORKTREE_DIR" -b "$FEATURE_NAME" 2>/dev/null || git worktree add "$WORKTREE_DIR" "$FEATURE_NAME"

    # Copy .claude directory if it exists in the original repo
    if [ -d "$GIT_ROOT/.claude" ]; then
        echo "üìã Copying .claude directory to worktree..."
        cp -rf "$GIT_ROOT/.claude" "$WORKTREE_DIR/.claude"
    fi

    # Change to worktree directory
    echo "üìÇ Switching to worktree directory..."
    cd "$WORKTREE_DIR"
}

# Auto-install dependencies if package files exist
auto_install_deps() {
    if [ -f "package.json" ]; then
        if command -v npm >/dev/null 2>&1; then
            echo "üì¶ Installing npm dependencies..."
            npm install
        fi
    elif [ -f "yarn.lock" ] && [ -f "package.json" ]; then
        if command -v yarn >/dev/null 2>&1; then
            echo "üß∂ Installing yarn dependencies..."
            yarn install
        fi
    elif [ -f "Cargo.toml" ]; then
        if command -v cargo >/dev/null 2>&1; then
            echo "ü¶Ä Building Rust project..."
            cargo build
        fi
    elif [ -f "requirements.txt" ]; then
        if command -v pip >/dev/null 2>&1; then
            echo "üêç Installing Python dependencies..."
            pip install -r requirements.txt
        fi
    elif [ -f "Gemfile" ]; then
        if command -v bundle >/dev/null 2>&1; then
            echo "üíé Installing Ruby dependencies..."
            bundle install
        fi
    fi
}

# Set up localias with random port
setup_localias() {
    if ! command -v localias >/dev/null 2>&1; then
        echo "‚ö†Ô∏è  localias not found, skipping local alias setup"
        echo "   Install with: go install github.com/peterldowns/localias@latest"
        return
    fi
    
    # Generate random port between PORT_MIN-PORT_MAX
    PORT=$((PORT_MIN + RANDOM % (PORT_MAX - PORT_MIN)))
    
    # Check if port is already in use, try a few times
    for i in $(seq 1 $PORT_RETRY_COUNT); do
        if ! lsof -i :$PORT >/dev/null 2>&1; then
            break
        fi
        PORT=$((PORT_MIN + RANDOM % (PORT_MAX - PORT_MIN)))
    done
    
    ALIAS="${FEATURE_NAME}.local"
    
    echo "üîó Setting up localias: $ALIAS -> localhost:$PORT"
    
    # Check if localias daemon is running, start if needed
    if ! localias status >/dev/null 2>&1; then
        echo "  Running: localias start"
        localias start >/dev/null 2>&1 || true
    else
        echo "  Localias daemon already running"
    fi
    
    # Set the alias
    echo "  Running: localias set $ALIAS $PORT"
    localias set "$ALIAS" "$PORT" >/dev/null 2>&1
    
    # Reload configuration if daemon is running
    if localias status >/dev/null 2>&1; then
        echo "  Running: localias reload"
        localias reload >/dev/null 2>&1 || true
    fi
    
    # Export environment variables for development
    export PORT
    export __VITE_ADDITIONAL_SERVER_ALLOWED_HOSTS="$ALIAS"
    echo "üì° Development server port: $PORT"
    echo "üåê Local alias: https://$ALIAS"
}

# Set tmux session title
set_terminal_title() {
    local title="$1"
    
    # Only rename tmux window
    if [ -n "$TMUX" ]; then
        tmux rename-window "$title"
    fi
}

set_terminal_title "${REPO_NAME}-${FEATURE_NAME}"

# Kill all processes in worktree directory except claude-worktree script
kill_worktree_processes() {
    if [ -d "$WORKTREE_DIR" ]; then
        echo "üî™ Killing processes in worktree directory..."
        
        # Get our script info for exclusion
        script_pid=$$
        script_name=$(basename "$0")
        
        # Get all processes using files in the worktree directory
        pids=$(lsof +D "$WORKTREE_DIR" 2>/dev/null | awk 'NR>1 {print $2}' | sort -u)
        
        for pid in $pids; do
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                # Skip our own process
                if [ "$pid" = "$script_pid" ]; then
                    echo "  Skipping claude-worktree script (PID $pid)"
                    continue
                fi
                
                # Get process info
                process_cmd=$(ps -p "$pid" -o args= 2>/dev/null || echo "unknown")
                
                # Skip if it's claude-worktree related
                case "$process_cmd" in
                    *"claude-worktree"*|*"$script_name"*)
                        echo "  Skipping claude-worktree process $pid: $process_cmd"
                        continue
                        ;;
                esac
                
                process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unknown")
                
                # Skip unknown processes for safety
                if [ "$process_name" = "unknown" ]; then
                    echo "  Skipping unknown process $pid"
                    continue
                fi
                
                echo "  Killing process $pid ($process_name): $process_cmd"
                kill "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null
            fi
        done
    fi
}

# Launch Claude with error recovery
launch_claude() {
    if ! claude; then
        echo ""
        echo "‚ö†Ô∏è  Claude exited with an error or was interrupted."
        
        if prompt_yes_no "Continue with merge/cleanup options anyway? (y/N): " "n"; then
            # Continue with merge/cleanup options
            true
        else
            kill_worktree_processes
            echo "üìÅ Worktree preserved at: $WORKTREE_DIR"
            echo "üåø Branch '$FEATURE_NAME' available for later work"
            echo "üßπ To clean up later: git worktree remove '$WORKTREE_DIR' && git branch -d '$FEATURE_NAME'"
            exit 0
        fi
    fi
    
    # Kill processes after Claude exits
    kill_worktree_processes
}

# Main execution function
main() {
    # Parse arguments and validate environment
    parse_arguments "$@"
    validate_environment

    # Handle clean mode if requested (exit early)
    if [ "$CLEAN_MODE" = true ]; then
        handle_clean_mode
        exit 0
    fi

    # Create worktree and setup environment
    create_worktree
    auto_install_deps
    setup_localias
    set_terminal_title "${REPO_NAME}-${FEATURE_NAME}"

    # Launch Claude
    launch_claude

    # Post-Claude processing
    echo ""
    echo "‚úÖ Claude session completed."

    # Handle merge and cleanup
    get_merge_preference
    if [ "$merge_type" != "no" ]; then
        handle_merge
        handle_push
        cleanup_after_merge
    else
        handle_no_merge_cleanup
    fi
}

# Get merge preference from user
get_merge_preference() {
    while true; do
        printf "Merge branch '$FEATURE_NAME' into main? (Y=merge, s=squash, n=no): "
        read -r merge_response
        
        case "$merge_response" in
        [yY] | [yY][eE][sS] | "")
            merge_type="merge"
            break
            ;;
        [sS] | [sS][qQ][uU][aA][sS][hH])
            merge_type="squash"
            break
            ;;
        [nN] | [nN][oO])
            merge_type="no"
            break
            ;;
        *)
            echo "Please answer Y (merge), s (squash), or n (no)"
            ;;
        esac
    done
}

# Handle the merge operation
handle_merge() {
    # Go back to original repo to merge
    cd "$GIT_ROOT"

    # Switch to main/master branch
    switch_to_main_branch

    if [ "$merge_type" = "squash" ]; then
        echo "üîÑ Squash merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --squash "$FEATURE_NAME"; then
            # Commit the squashed changes (opens editor)
            if git commit; then
                echo "‚úÖ Squash merge successful!"
                merge_successful=true
            else
                echo "Commit cancelled or failed."
                echo "Worktree preserved at: $WORKTREE_DIR"
                echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
                exit 1
            fi
        else
            echo "Squash merge conflicts detected. Please resolve them manually."
            echo "Worktree preserved at: $WORKTREE_DIR"
            echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
            exit 1
        fi
    else
        echo "üîÄ Merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --no-edit "$FEATURE_NAME"; then
            echo "‚úÖ Merge successful!"
            merge_successful=true
        else
            echo "Merge conflicts detected. Please resolve them manually."
            echo "Worktree preserved at: $WORKTREE_DIR"
            echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
            exit 1
        fi
    fi
}

# Handle pushing changes to remote
handle_push() {
    if [ "$merge_successful" = true ]; then
        if git diff --quiet && git diff --cached --quiet; then
            echo "üöÄ Auto-pushing to remote (no unstaged changes)..."
            current_branch=$(git symbolic-ref --short HEAD)
            git push
        else
            if prompt_yes_no "Push changes to remote? (y/N): " "n"; then
                current_branch=$(git symbolic-ref --short HEAD)
                echo "üöÄ Pushing $current_branch to remote..."
                git push
            fi
        fi
    fi
}

# Clean up worktree and branch after merge
cleanup_after_merge() {
    perform_cleanup "true"
}
# Handle cleanup when no merge is performed
handle_no_merge_cleanup() {
    echo "Skipping merge."
    
    # Ask about cleanup only if no merge
    if prompt_yes_no "Do you want to delete the worktree and branch '$FEATURE_NAME'? (y/N): " "n"; then
        perform_cleanup "true"
    else
        echo "Worktree preserved at: $WORKTREE_DIR"
        echo "To merge later: git merge '$FEATURE_NAME'"
        echo "To clean up later: git worktree remove '$WORKTREE_DIR' && git branch -d '$FEATURE_NAME'"
    fi
}

# Execute main function with all arguments
main "$@"
