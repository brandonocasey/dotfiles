#!/bin/bash
set -e

ORIGINAL_ARGS=("$@")

# Print cleanup instructions
print_cleanup_instructions() {
    echo "üìÅ Worktree preserved at: $WORKTREE_DIR"
    echo "üåø Branch '$FEATURE_NAME' available for later work"
    echo ""
    echo "Options:"
    echo "  cd $WORKTREE_DIR                                      # Continue working"
    echo "  git worktree-helper --update '$FEATURE_NAME'          # Update with latest from main"
    echo "  git worktree-helper --merge '$FEATURE_NAME'           # Merge and keep worktree"
    echo "  git worktree-helper --merge --clean '$FEATURE_NAME'   # Merge and cleanup"
    echo "  git worktree-helper --clean '$FEATURE_NAME'           # Remove worktree and branch"
}

# Install shell completions
install_completions() {
    echo "üîß Installing shell completions for git-worktree-helper"
    echo ""

    # Detect shell
    local shell_name
    shell_name=$(basename "${SHELL:-bash}")

    case "$shell_name" in
    fish)
        local fish_completions_dir="$HOME/.config/fish/completions"
        local completion_file="$fish_completions_dir/git-worktree-helper.fish"

        # Create directory if it doesn't exist
        if [ ! -d "$fish_completions_dir" ]; then
            mkdir -p "$fish_completions_dir"
            echo "üìÅ Created directory: $fish_completions_dir"
        fi

        # Check if completion file already exists
        if [ -f "$completion_file" ]; then
            echo "‚ö†Ô∏è  Fish completion file already exists: $completion_file"
            if ! prompt_yes_no "Overwrite existing completion file? (y/N): " "n"; then
                echo "Skipped Fish completions installation"
                return
            fi
        fi

        # Write Fish completion file
        cat > "$completion_file" << 'EOF'
# Fish completion for git-worktree-helper

# Complete branch names for --clean and --merge (only existing worktrees/branches)
function __git_worktree_helper_existing_branches
    # Get branches that have corresponding worktrees
    if git rev-parse --git-dir >/dev/null 2>&1
        set repo_name (basename (git rev-parse --show-toplevel))
        set parent_dir (dirname (git rev-parse --show-toplevel))

        for branch in (git branch --format='%(refname:short)' 2>/dev/null)
            set worktree_dir "$parent_dir/$repo_name-$branch"
            if test -d "$worktree_dir"
                echo $branch
            end
        end
    end
end

# Complete feature names (any valid branch name or new feature name)
function __git_worktree_helper_all_branches
    if git rev-parse --git-dir >/dev/null 2>&1
        git branch --format='%(refname:short)' 2>/dev/null
    end
end

# Complete options
complete -c git-worktree-helper -s h -l help -d "Show help message"
complete -c git-worktree-helper -l init -d "Create template config file"
complete -c git-worktree-helper -l list -d "List all active worktrees"
complete -c git-worktree-helper -l install-completions -d "Install shell completions"
complete -c git-worktree-helper -l update -d "Update feature branch with base branch" -xa "(__git_worktree_helper_existing_branches)"
complete -c git-worktree-helper -l clean -d "Remove worktree and branch (composable)" -xa "(__git_worktree_helper_existing_branches)"
complete -c git-worktree-helper -l merge -d "Merge branch into main" -xa "(__git_worktree_helper_existing_branches)"
complete -c git-worktree-helper -l squash -d "Squash merge branch into main" -xa "(__git_worktree_helper_existing_branches)"

# Complete feature names for the main argument
complete -c git-worktree-helper -f -n "not __fish_seen_subcommand_from --clean --merge --squash --update --init --list --install-completions" -xa "(__git_worktree_helper_all_branches)"
EOF

        echo "‚úÖ Installed Fish completions: $completion_file"
        echo ""
        echo "Completions will be available in new Fish shell sessions."
        echo "To use immediately, run: source $completion_file"
        ;;
    bash)
        echo "‚ö†Ô∏è  Bash completions not yet implemented"
        ;;
    zsh)
        echo "‚ö†Ô∏è  Zsh completions not yet implemented"
        ;;
    *)
        echo "‚ö†Ô∏è  Shell '$shell_name' not supported for completions"
        echo "Supported shells: fish"
        ;;
    esac
}

# Create template config file
init_config() {
    local config_dir="$GIT_ROOT/.config"
    local config_file="$config_dir/git-worktree-helper.sh"

    # Create .config directory if it doesn't exist
    if [ ! -d "$config_dir" ]; then
        mkdir -p "$config_dir"
        echo "üìÅ Created directory: $config_dir"
    fi

    # Check if config already exists
    local config_exists=false
    if [ -f "$config_file" ]; then
        echo "‚úÖ Config file already exists: $config_file"
        config_exists=true
    fi

    # Write template config only if it doesn't exist
    if [ "$config_exists" = false ]; then
        cat > "$config_file" << 'EOF'
#!/bin/bash
# Worktree Configuration
# This file configures behavior for git-worktree-helper

# Optional setup hook (runs after worktree creation)
# Receives two arguments: $1=repo_root, $2=worktree_path
# Example: Start a dev server, run builds, etc.
setup_hook() {
    local repo_root="$1"
    local worktree_path="$2"

    # Your setup commands here
    # echo "Running custom setup in $worktree_path"
}

# Optional teardown hook (runs before worktree cleanup)
# Receives two arguments: $1=repo_root, $2=worktree_path
# Example: Save logs, backup data, etc.
teardown_hook() {
    local repo_root="$1"
    local worktree_path="$2"

    # Your teardown commands here
    # echo "Running custom teardown in $worktree_path"
}

# Additional environment variables for .env.local
# These will be appended to the generated .env.local file
# Example:
# ENV_VARS=(
#   "DATABASE_URL=postgresql://localhost/mydb"
#   "API_KEY=your-key-here"
# )
ENV_VARS=()
EOF

        chmod +x "$config_file"
        echo "‚úÖ Created template config: $config_file"
        echo ""
    fi

    # Check if .git-worktree-helper/ will be gitignored
    local gitignore="$GIT_ROOT/.gitignore"
    local needs_gitignore=true

    if [ -f "$gitignore" ]; then
        if grep -q "\\.git-worktree-helper" "$gitignore"; then
            needs_gitignore=false
            echo "‚úÖ .git-worktree-helper/ is already in .gitignore"
        fi
    fi

    if [ "$needs_gitignore" = true ]; then
        echo "‚ö†Ô∏è  .git-worktree-helper/ is not in .gitignore"
        if prompt_yes_no "Add .git-worktree-helper/ to .gitignore? (Y/n): " "y"; then
            echo ".git-worktree-helper/" >> "$gitignore"
            echo "‚úÖ Added .git-worktree-helper/ to .gitignore"
        else
            echo "‚ö†Ô∏è  Warning: .git-worktree-helper/ should be added to .gitignore"
        fi
    fi

    if [ "$config_exists" = false ]; then
        echo ""
        echo "Edit this file to customize your worktree setup."
    fi
}

# Load configuration
load_config() {
    # Load config if it exists
    local config_file="$GIT_ROOT/.config/git-worktree-helper.sh"
    if [ -f "$config_file" ]; then
        echo "üìù Loading config from $config_file"
        set -a
        # shellcheck disable=SC1090
        source "$config_file"
        set +a
    fi
}

# Validate feature name for tmux compatibility
validate_feature_name() {
    # Tmux session names: alphanumeric, hyphens, underscores only
    if ! echo "$FEATURE_NAME" | grep -qE '^[a-zA-Z0-9_-]+$'; then
        echo "Error: Feature name '$FEATURE_NAME' is invalid"
        echo "Feature names must contain only: letters, numbers, hyphens (-), and underscores (_)"
        exit 1
    fi
}

ensure_tmux_session() {
    if [ -n "$TMUX" ]; then
        if [ -z "$GIT_WT_TMUX_SESSION" ]; then
            GIT_WT_TMUX_SESSION=$(tmux display-message -p '#S' 2>/dev/null || printf 'tmux')
            export GIT_WT_TMUX_SESSION
        fi
        return
    fi

    # Skip tmux creation if --no-tmux flag is set or if we're in specific modes
    if [ "$NO_TMUX_MODE" = true ] || [ "$MERGE_MODE" = true ] || [ "$SQUASH_MODE" = true ] || [ "$UPDATE_MODE" = true ] || [ "$CLEAN_FLAG" = true ] || [ "$INIT_MODE" = true ] || [ "$LIST_MODE" = true ] || [ "$INSTALL_COMPLETIONS_MODE" = true ]; then
        return
    fi

    if ! command -v tmux >/dev/null 2>&1; then
        echo "Error: tmux is required but not installed"
        exit 1
    fi

    local base_name="wt-${FEATURE_NAME:-session}"
    base_name=${base_name//[^a-zA-Z0-9_-]/-}
    local session_name="${base_name}-$$"

    local script_path
    script_path=$(realpath "$0" 2>/dev/null || echo "$0")

    echo "ü™ü Launching tmux session '$session_name'..."

    exec tmux new-session -s "$session_name" /usr/bin/env GIT_WT_TMUX_CHILD=1 GIT_WT_TMUX_SESSION="$session_name" "$script_path" "${ORIGINAL_ARGS[@]}"
}

sanitize_tmux_component() {
    local value="$1"
    value=$(printf '%s' "${value:-session}" | tr -c '[:alnum:]_-' '-')
    value=$(printf '%s' "$value" | sed -E 's/-+/-/g; s/^-//; s/-$//')
    if [ -z "$value" ]; then
        value="session"
    fi
    printf '%s' "$value"
}

rename_tmux_session() {
    local feature_component port_component session_name

    feature_component=$(sanitize_tmux_component "${FEATURE_NAME:-feature}")
    port_component=$(sanitize_tmux_component "${PORT:-noport}")
    session_name="${feature_component}-${port_component}"

    echo "üè∑Ô∏è  Renaming tmux session to: $session_name"
    if ! tmux rename-session "$session_name"; then
        echo "‚ö†Ô∏è  Failed to rename tmux session. Keeping existing name."
    fi
}

keep_tmux_session_alive() {
    local exit_status="$1"
    if [ "$GIT_WT_TMUX_CHILD" = "1" ] && [ -n "$TMUX" ]; then
        local session_label shell_path original_status

        session_label="$(tmux display-message -p '#S' 2>/dev/null)"

        if [ -z "$session_label" ]; then
            session_label="${GIT_WT_TMUX_SESSION:-tmux}"
        fi

        if [ "$exit_status" -ne 0 ]; then
            echo "‚ö†Ô∏è  git-worktree-helper exited with status $exit_status in session '$session_label'."
        else
            echo "‚úÖ git-worktree-helper finished in session '$session_label'."
        fi
        echo "‚å®Ô∏è  Opening interactive shell; type 'exit' to close the tmux session."

        shell_path="${SHELL:-/bin/bash}"
        original_status="$exit_status"

        if [ "${GIT_WT_KEEP_RC:-0}" = "1" ]; then
            "$shell_path" -i || true
        else
            case "$(basename "$shell_path")" in
            bash)
                "$shell_path" --noprofile --norc -i || true
                ;;
            zsh)
                "$shell_path" -f -i || true
                ;;
            fish)
                "$shell_path" --private || true
                ;;
            *)
                "$shell_path" -i || true
                ;;
            esac
        fi

        exit "$original_status"
    fi

    exit "$exit_status"
}

# Load session state from .env.local
load_session_state() {
    local env_file="$WORKTREE_DIR/.env.local"

    if [ -f "$env_file" ]; then
        echo "üìù Loading session state from $env_file"
        set -a
        # shellcheck disable=SC1090
        source "$env_file"
        set +a

        if [ -n "$PORT" ]; then
            export PORT
            echo "üîå Restored PORT: $PORT"
        fi

        if [ -n "$FEATURE_NAME" ]; then
            echo "üåø Restored FEATURE_NAME: $FEATURE_NAME"
        fi
    fi
}

# Generate .env.local file
generate_env_local() {
    local env_file="$WORKTREE_DIR/.env.local"

    echo "üìù Generating $env_file"

    {
        echo "# Generated by git-worktree-helper on $(date)"
        echo "PORT=$PORT"
        echo "FEATURE_NAME=$FEATURE_NAME"
        echo "CREATED_AT=$(date +%s)"

        # Add custom environment variables from config
        if [ ${#ENV_VARS[@]} -gt 0 ]; then
            echo ""
            echo "# Custom environment variables"
            for var in "${ENV_VARS[@]}"; do
                echo "$var"
            done
        fi
    } > "$env_file"

    echo "‚úÖ Created .env.local with PORT=$PORT"
}

# Auto-install dependencies based on detected package managers
install_dependencies() {
    local yarn_lock="yarn.lock"
    local package_json="package.json"

    # Check for Node.js dependencies (prefer yarn over npm)
    if [ -f "$yarn_lock" ] && [ -f "$package_json" ] && command -v yarn >/dev/null 2>&1; then
        echo "üß∂ Installing yarn dependencies..."
        yarn install --frozen-lockfile
    elif [ -f "$package_json" ] && command -v npm >/dev/null 2>&1; then
        echo "üì¶ Installing npm dependencies..."
        npm ci 2>/dev/null || npm install
    fi

    # Check other package managers
    if [ -f "Cargo.toml" ] && command -v cargo >/dev/null 2>&1; then
        echo "ü¶Ä Building Rust project..."
        cargo build
    fi

    if [ -f "requirements.txt" ] && command -v pip >/dev/null 2>&1; then
        echo "üêç Installing Python dependencies..."
        pip install -r requirements.txt
    fi

    if [ -f "Gemfile" ] && command -v bundle >/dev/null 2>&1; then
        echo "üíé Installing Ruby dependencies..."
        bundle install
    fi
}

# Create and setup the worktree
setup_worktree() {
    echo "üìÅ Creating worktree at: $WORKTREE_DIR"
    echo "üåø Branch: $FEATURE_NAME"

    # Create worktree (create new branch or use existing)
    if git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
        echo "   Using existing branch '$FEATURE_NAME'"
        git worktree add "$WORKTREE_DIR" "$FEATURE_NAME"
    else
        echo "   Creating new branch '$FEATURE_NAME'"
        git worktree add "$WORKTREE_DIR" -b "$FEATURE_NAME"
    fi

    # Change to worktree directory
    echo "üìÇ Switching to worktree directory..."
    cd "$WORKTREE_DIR"

    # Create .git-worktree-helper directory for cleanup tracking
    mkdir -p "$WORKTREE_DIR/.git-worktree-helper"

    # Load configuration
    load_config

    # Generate random port if not already set
    if [ -z "$PORT" ]; then
        if command -v jot >/dev/null 2>&1; then
            PORT=$(jot -r 1 3000 9999)
        elif command -v shuf >/dev/null 2>&1; then
            PORT=$(shuf -i 3000-9999 -n 1)
        else
            PORT=$((3000 + RANDOM % 7000))
        fi
        echo "üîå Generated PORT: $PORT"
    fi

    export PORT

    # Rename tmux session to feature name
    rename_tmux_session

    # Generate .env.local (includes state persistence)
    generate_env_local

    # Auto-install dependencies
    install_dependencies

    # Run setup hook if defined
    if type -t setup_hook >/dev/null 2>&1; then
        echo "üîß Running setup hook..."
        setup_hook "$GIT_ROOT" "$WORKTREE_DIR" || echo "‚ö†Ô∏è  Setup hook failed"
    fi

    echo ""
    echo "‚úÖ Worktree ready at: $WORKTREE_DIR"
    echo "üîå PORT=$PORT"
    echo ""
}

# Switch to main/master branch
switch_to_main_branch() {
    local current_branch
    current_branch=$(git symbolic-ref --short HEAD)
    if [ "$current_branch" != "main" ] && [ "$current_branch" != "master" ]; then
        git checkout main 2>/dev/null || git checkout master 2>/dev/null || {
            echo "Error: Could not switch to main/master branch"
            exit 1
        }
    fi
}

# Remove branch with force delete
remove_branch() {
    if git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
        echo "üåø Removing branch: $FEATURE_NAME"
        git branch -D "$FEATURE_NAME" 2>/dev/null || {
            echo "Warning: Could not remove branch '$FEATURE_NAME'"
        }
    fi
}

# Get merge and cleanup preference
get_merge_and_cleanup_choice() {
    trap 'echo ""; echo "‚ùå Cancelled - preserving worktree"; print_cleanup_instructions; exit 0' INT

    local selected=1
    local options=(
        "Merge + Clean       [DEFAULT] - Merge into main and remove worktree/branch"
        "Squash + Clean                - Squash merge into main and remove worktree/branch"
        "Throw Away                    - Remove worktree and branch without merging"
        "Merge (Keep)                  - Merge into main but keep worktree/branch"
        "Squash (Keep)                 - Squash merge into main but keep worktree/branch"
        "Do Nothing                    - Preserve worktree and branch for later"
    )
    local actions=("merge-clean" "squash-clean" "throw-away" "merge-keep" "squash-keep" "do-nothing")

    echo ""
    echo "What would you like to do with branch '$FEATURE_NAME'?"
    echo ""
    for i in "${!options[@]}"; do
        printf "  %d. %s\\n" "$((i + 1))" "${options[$i]}"
    done
    echo ""

    while true; do
        printf "Choose an option [1-6] (default=1, ESC or Ctrl+C to cancel): "

        if read -r choice 2>/dev/null; then
            : # Successfully read input
        else
            echo ""
            echo "‚ùå Cancelled - preserving worktree"
            print_cleanup_instructions
            exit 0
        fi

        if [[ "$choice" == $'\x1b' ]] || [[ "$choice" == "q" ]]; then
            echo ""
            echo "‚ùå Cancelled - preserving worktree"
            print_cleanup_instructions
            exit 0
        fi

        if [ -z "$choice" ]; then
            selected=1
            break
        fi

        if [[ "$choice" =~ ^[1-6]$ ]]; then
            selected=$choice
            break
        else
            echo "Invalid choice. Please enter a number from 1 to 6."
        fi
    done

    merge_action="${actions[$((selected - 1))]}"
    trap - INT
}

# Execute merge operation
execute_merge() {
    local merge_type="$1"  # "merge" or "squash"
    local merge_successful=false

    cd "$GIT_ROOT"
    switch_to_main_branch

    if [ "$merge_type" = "squash" ]; then
        echo "üîÑ Squash merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --squash "$FEATURE_NAME"; then
            if git commit; then
                echo "‚úÖ Squash merge successful!"
                merge_successful=true
            else
                echo "‚ùå Commit cancelled or failed."
                print_cleanup_instructions
                exit 1
            fi
        else
            echo "‚ùå Squash merge conflicts detected. Please resolve them manually."
            print_cleanup_instructions
            exit 1
        fi
    else
        echo "üîÄ Merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --no-edit "$FEATURE_NAME"; then
            echo "‚úÖ Merge successful!"
            merge_successful=true
        else
            echo "‚ùå Merge conflicts detected. Please resolve them manually."
            print_cleanup_instructions
            exit 1
        fi
    fi

    if [ "$merge_successful" = true ]; then
        echo "üöÄ Pushing to remote..."
        git push
    fi
}

# Execute update operation
execute_update_operation() {
    echo "üîÑ Update mode: merging base branch into feature '$FEATURE_NAME'"

    validate_existing_feature

    # Determine the base branch (main or master)
    cd "$GIT_ROOT"
    local base_branch
    if git show-ref --verify --quiet refs/heads/main; then
        base_branch="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        base_branch="master"
    else
        echo "Error: Could not find main or master branch"
        exit 1
    fi

    echo "üì• Fetching latest changes from remote..."
    git fetch origin "$base_branch"

    # Switch to the worktree and merge base branch into feature branch
    cd "$WORKTREE_DIR"

    echo "üîÄ Merging '$base_branch' into feature branch '$FEATURE_NAME'..."
    if git merge "origin/$base_branch" --no-edit; then
        echo "‚úÖ Update successful! Feature branch '$FEATURE_NAME' is now up to date with $base_branch"
        echo ""
        echo "üìÅ Worktree: $WORKTREE_DIR"
    else
        echo "‚ùå Merge conflicts detected. Please resolve them manually in the worktree."
        echo "üìÅ Worktree: $WORKTREE_DIR"
        exit 1
    fi
}

# Execute merge operation
execute_merge_operation() {
    if [ "$SQUASH_MODE" = true ]; then
        echo "üîÑ Squash merge mode: merging feature '$FEATURE_NAME'"
    else
        echo "üîÄ Merge mode: merging feature '$FEATURE_NAME'"
    fi

    validate_existing_feature

    # Perform the merge directly without the interactive menu
    cd "$GIT_ROOT"
    switch_to_main_branch

    if [ "$SQUASH_MODE" = true ]; then
        echo "üîÑ Squash merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --squash "$FEATURE_NAME"; then
            if git commit; then
                echo "‚úÖ Squash merge successful!"
                git push
            else
                echo "‚ùå Commit cancelled or failed."
                exit 1
            fi
        else
            echo "‚ùå Squash merge conflicts detected. Please resolve them manually."
            exit 1
        fi
    else
        echo "üîÄ Merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --no-edit "$FEATURE_NAME"; then
            echo "‚úÖ Merge successful!"
            git push
        else
            echo "‚ùå Merge conflicts detected. Please resolve them manually."
            exit 1
        fi
    fi

    echo ""
    echo "‚úÖ Merge complete for feature '$FEATURE_NAME'"
}

# Execute clean operation
execute_clean_operation() {
    perform_cleanup
}

# Handle existing feature detection
handle_existing_feature() {
    echo "‚ö†Ô∏è  A worktree for '$FEATURE_NAME' already exists at: $WORKTREE_DIR"
    echo ""
    echo "What would you like to do?"
    echo "  1. Continue working (cd to worktree)"
    echo "  2. Merge and cleanup the feature"
    echo "  3. Clean up the feature (remove worktree and branch)"
    echo "  4. Clean up and restart (remove and create fresh worktree)"
    echo "  5. Cancel (preserve existing worktree)"
    echo ""

    while true; do
        printf "Choose an option (1-5): "
        read -r choice

        case "$choice" in
        1)
            echo ""
            echo "üìÅ Worktree exists at: $WORKTREE_DIR"
            echo "To continue working, run: cd $WORKTREE_DIR"
            exit 0
            ;;
        2)
            execute_merge_operation
            exit 0
            ;;
        3)
            perform_cleanup
            exit 0
            ;;
        4)
            echo ""
            echo "‚Üí Cleaning up and restarting with fresh worktree..."
            perform_cleanup
            echo ""
            echo "‚úÖ Cleanup complete. Creating fresh worktree..."
            return
            ;;
        5)
            echo "‚ùå Cancelled - existing worktree preserved at: $WORKTREE_DIR"
            print_cleanup_instructions
            exit 0
            ;;
        *)
            echo "Invalid choice. Please enter 1, 2, 3, 4, or 5."
            ;;
        esac
    done
}

# Handle merge and cleanup flow
handle_merge_and_cleanup() {
    get_merge_and_cleanup_choice

    case "$merge_action" in
    merge-clean)
        echo ""
        echo "‚Üí Merging and cleaning up..."
        execute_merge "merge"
        perform_cleanup
        ;;
    squash-clean)
        echo ""
        echo "‚Üí Squash merging and cleaning up..."
        execute_merge "squash"
        perform_cleanup
        ;;
    throw-away)
        echo ""
        echo "‚Üí Throwing away changes and cleaning up..."
        perform_cleanup
        ;;
    merge-keep)
        echo ""
        echo "‚Üí Merging and keeping worktree..."
        execute_merge "merge"
        echo ""
        echo "‚úÖ Merge complete. Worktree and branch preserved."
        print_cleanup_instructions
        ;;
    squash-keep)
        echo ""
        echo "‚Üí Squash merging and keeping worktree..."
        execute_merge "squash"
        echo ""
        echo "‚úÖ Squash merge complete. Worktree and branch preserved."
        print_cleanup_instructions
        ;;
    do-nothing)
        echo ""
        echo "‚Üí Doing nothing - preserving worktree and branch"
        print_cleanup_instructions
        ;;
    *)
        echo "Error: Unknown merge action '$merge_action'"
        exit 1
        ;;
    esac
}

# Validate existing feature
validate_existing_feature() {
    if [ "$FEATURE_VALIDATED" = true ]; then
        return
    fi

    if [ ! -d "$WORKTREE_DIR" ] && ! git worktree list | grep -q "$WORKTREE_DIR"; then
        echo "Error: No worktree found for feature '$FEATURE_NAME' at: $WORKTREE_DIR"
        exit 1
    fi

    if ! git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
        echo "Error: Branch '$FEATURE_NAME' does not exist"
        exit 1
    fi

    FEATURE_VALIDATED=true
}

# Generic yes/no prompt
prompt_yes_no() {
    local prompt="$1"
    local default="$2" # "y" or "n"

    while true; do
        printf "%s" "$prompt"
        read -r response

        case "$response" in
        [yY] | [yY][eE][sS])
            return 0
            ;;
        [nN] | [nN][oO])
            return 1
            ;;
        "")
            if [ "$default" = "y" ]; then
                return 0
            else
                return 1
            fi
            ;;
        *)
            echo "Please answer y(es) or n(o)"
            ;;
        esac
    done
}

# Start async cleanup
start_async_cleanup() {
    local feature_name="$1"
    local worktree_dir="$2"
    local git_root="$3"

    local cleanup_tracking_dir="$git_root/.git-worktree-helper/cleanups"
    mkdir -p "$cleanup_tracking_dir"

    local cleanup_id
    cleanup_id="${feature_name}-$$-$(date +%s)"
    local cleanup_log="$cleanup_tracking_dir/${cleanup_id}.log"
    local cleanup_pid_file="$cleanup_tracking_dir/${cleanup_id}.pid"

    echo "üßπ Starting background cleanup for feature: $feature_name"
    echo "üìù Cleanup log: $cleanup_log"

    (
        trap '' HUP
        exec 0</dev/null

        {
            echo "=== Cleanup started at $(date) ==="
            echo "Feature: $feature_name"
            echo "Worktree: $worktree_dir"
            echo "PID: $$"
            echo ""

            # Run teardown hook if defined
            if type -t teardown_hook >/dev/null 2>&1; then
                echo "üîß Running teardown hook..."
                cd "$worktree_dir" 2>/dev/null || true
                teardown_hook "$git_root" "$worktree_dir" || true
                cd "$git_root"
            fi

            # Kill processes in worktree
            if [ -d "$worktree_dir" ]; then
                echo "üî™ Killing processes in worktree..."

                if command -v timeout >/dev/null 2>&1; then
                    pids=$(timeout 5 lsof +D "$worktree_dir" 2>/dev/null | awk 'NR>1 {print $2}' | sort -u || true)
                elif command -v gtimeout >/dev/null 2>&1; then
                    pids=$(gtimeout 5 lsof +D "$worktree_dir" 2>/dev/null | awk 'NR>1 {print $2}' | sort -u || true)
                else
                    pids=$(lsof +D "$worktree_dir" 2>/dev/null | awk 'NR>1 {print $2}' | sort -u || true)
                fi

                for pid in $pids; do
                    echo "  Killing process $pid"
                    kill "$pid" 2>/dev/null || true
                    sleep 0.1
                    kill -9 "$pid" 2>/dev/null || true
                done

                echo "‚è≥ Waiting for processes to exit..."
                sleep 1
            fi

            # Backup files
            echo "üíæ Backing up files..."
            local backup_dir="$git_root/.git-worktree-helper/backups"
            local backup_file="$backup_dir/$feature_name-$(date +%Y%m%d-%H%M%S).tar.gz"
            mkdir -p "$backup_dir"

            if [ -d "$worktree_dir" ]; then
                cd "$worktree_dir" 2>/dev/null || true
                git ls-files --cached --others --exclude-standard 2>/dev/null | \
                    tar czf "$backup_file" -T - 2>/dev/null || true
                cd "$git_root"
                if [ -f "$backup_file" ] && [ -s "$backup_file" ]; then
                    echo "‚úÖ Backed up files to: $backup_file"
                else
                    echo "‚ö†Ô∏è  No files to backup"
                    rm -f "$backup_file" 2>/dev/null || true
                fi
            fi

            # Remove tracking directory
            echo "üóëÔ∏è  Removing .git-worktree-helper tracking directory..."
            rm -rf "$worktree_dir/.git-worktree-helper" 2>/dev/null || true

            # Remove worktree
            echo "üßπ Removing worktree..."
            if [ -d "$worktree_dir" ] || git -C "$git_root" worktree list | grep -q "$worktree_dir"; then
                if command -v timeout >/dev/null 2>&1; then
                    timeout 30 git -C "$git_root" worktree remove --force "$worktree_dir" || {
                        echo "‚ö†Ô∏è  Timed out, forcing with rm..."
                        rm -rf "$worktree_dir" 2>/dev/null || true
                        git -C "$git_root" worktree prune 2>/dev/null || true
                    }
                elif command -v gtimeout >/dev/null 2>&1; then
                    gtimeout 30 git -C "$git_root" worktree remove --force "$worktree_dir" || {
                        echo "‚ö†Ô∏è  Timed out, forcing with rm..."
                        rm -rf "$worktree_dir" 2>/dev/null || true
                        git -C "$git_root" worktree prune 2>/dev/null || true
                    }
                else
                    git -C "$git_root" worktree remove --force "$worktree_dir" || {
                        echo "‚ö†Ô∏è  Failed, forcing with rm..."
                        rm -rf "$worktree_dir" 2>/dev/null || true
                        git -C "$git_root" worktree prune 2>/dev/null || true
                    }
                fi
            fi

            # Remove branch
            echo "üåø Removing branch..."
            if git -C "$git_root" show-ref --verify --quiet refs/heads/"$feature_name"; then
                git -C "$git_root" branch -D "$feature_name" 2>/dev/null || echo "‚ö†Ô∏è  Could not remove branch"
            fi

            echo ""
            echo "‚ú® Cleanup completed at $(date)"
        } >> "$cleanup_log" 2>&1

        rm -f "$cleanup_pid_file"
    ) &

    local cleanup_pid=$!
    echo "$cleanup_pid" > "$cleanup_pid_file"
    disown "$cleanup_pid" 2>/dev/null || true

    echo "‚úÖ Background cleanup started (PID: $cleanup_pid)"
    echo "   Check status with: git worktree-helper --list"
    echo "   View log: tail -f $cleanup_log"
}

# Unified cleanup function
perform_cleanup() {
    cd "$GIT_ROOT"

    if [ ! -d "$WORKTREE_DIR" ] && ! git worktree list | grep -q "$WORKTREE_DIR"; then
        echo "No worktree found for '$FEATURE_NAME' - nothing to clean up"
        remove_branch
        return
    fi

    load_config

    # Check for uncommitted changes
    if ! git -C "$WORKTREE_DIR" diff --quiet || ! git -C "$WORKTREE_DIR" diff --cached --quiet || [ -n "$(git -C "$WORKTREE_DIR" ls-files --others --exclude-standard)" ]; then
        echo "‚ö†Ô∏è  Warning: The worktree has uncommitted changes."

        cd "$WORKTREE_DIR"
        git status --short
        cd "$GIT_ROOT"

        if ! prompt_yes_no "Start background cleanup anyway? This will remove uncommitted changes. (y/N): " "n"; then
            print_cleanup_instructions
            return
        fi

        echo "‚úÖ Proceeding with cleanup..."
    fi

    start_async_cleanup "$FEATURE_NAME" "$WORKTREE_DIR" "$GIT_ROOT"
}

# List all worktrees
list_worktrees() {
    echo "üîç Active worktrees:"
    echo ""

    local found_any=false
    local git_root
    git_root="$(git rev-parse --show-toplevel 2>/dev/null)"

    if [ -z "$git_root" ]; then
        echo "Error: Not in a git repository"
        exit 1
    fi

    while IFS= read -r line; do
        if [[ "$line" =~ ^worktree ]]; then
            local worktree_path="${line#worktree }"
            local branch="" commit="" port=""

            while IFS= read -r info_line; do
                if [[ "$info_line" =~ ^branch ]]; then
                    branch="${info_line#branch refs/heads/}"
                elif [[ "$info_line" =~ ^HEAD ]]; then
                    commit="${info_line#HEAD }"
                    commit="${commit:0:7}"
                elif [[ -z "$info_line" ]]; then
                    break
                fi
            done

            # Check if this is a git-worktree-helper worktree
            if [ -f "$worktree_path/.env.local" ]; then
                found_any=true

                # Load state
                port=""
                if [ -r "$worktree_path/.env.local" ]; then
                    # shellcheck disable=SC1090
                    source "$worktree_path/.env.local" 2>/dev/null || true
                fi

                echo "üìÅ Branch: $branch"
                echo "   Path: $worktree_path"
                echo "   Port: ${PORT:-none}"
                echo "   Commit: $commit"
                echo ""
            fi
        fi
    done < <(git worktree list --porcelain)

    if [ "$found_any" = false ]; then
        echo "No active git-worktree-helper worktrees found."
        echo ""
        echo "Create one with: git worktree-helper <feature-name>"
    fi

    # Check for running cleanups
    local cleanup_dir="$git_root/.git-worktree-helper/cleanups"
    if [ -d "$cleanup_dir" ]; then
        local found_cleanups=false

        for pid_file in "$cleanup_dir"/*.pid; do
            [ -e "$pid_file" ] || continue

            local cleanup_pid
            cleanup_pid=$(cat "$pid_file" 2>/dev/null)

            if [ -n "$cleanup_pid" ] && kill -0 "$cleanup_pid" 2>/dev/null; then
                if [ "$found_cleanups" = false ]; then
                    echo ""
                    echo "üßπ Running cleanup operations:"
                    echo ""
                    found_cleanups=true
                fi

                local cleanup_id
                cleanup_id=$(basename "$pid_file" .pid)
                local feature_name="${cleanup_id%%-*}"
                local log_file="$cleanup_dir/${cleanup_id}.log"

                echo "üîÑ Feature: $feature_name"
                echo "   PID: $cleanup_pid"
                echo "   Log: $log_file"

                if [ -f "$log_file" ] && [ -r "$log_file" ]; then
                    local last_line
                    last_line=$(tail -n 1 "$log_file" 2>/dev/null)
                    if [ -n "$last_line" ]; then
                        echo "   Status: $last_line"
                    fi
                fi
                echo ""
            else
                rm -f "$pid_file" 2>/dev/null || true
            fi
        done

        # Clean up old logs (older than 7 days)
        find "$cleanup_dir" -name "*.log" -mtime +7 -delete 2>/dev/null || true
    fi
}

# Setup environment
setup_environment() {
    if [ "$INIT_MODE" = false ] && [ "$LIST_MODE" = false ] && [ "$INSTALL_COMPLETIONS_MODE" = false ]; then
        validate_feature_name
    fi

    ensure_tmux_session

    if [ "$INSTALL_COMPLETIONS_MODE" = true ]; then
        return
    fi

    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: Not in a git repository"
        exit 1
    fi

    GIT_ROOT="$(git rev-parse --show-toplevel)"
    REPO_NAME="$(basename "$GIT_ROOT")"
    PARENT_DIR="$(dirname "$GIT_ROOT")"

    if [ -n "$FEATURE_NAME" ]; then
        WORKTREE_DIR="${PARENT_DIR}/${REPO_NAME}-${FEATURE_NAME}"
    fi
}

# Parse arguments
parse_arguments() {
    CLEAN_FLAG=false
    MERGE_MODE=false
    SQUASH_MODE=false
    UPDATE_MODE=false
    INIT_MODE=false
    LIST_MODE=false
    INSTALL_COMPLETIONS_MODE=false
    NO_TMUX_MODE=false
    FEATURE_NAME=""

    while [ $# -gt 0 ]; do
        case $1 in
        --init)
            INIT_MODE=true
            shift
            ;;
        --install-completions)
            INSTALL_COMPLETIONS_MODE=true
            shift
            ;;
        --list)
            LIST_MODE=true
            shift
            ;;
        --squash)
            SQUASH_MODE=true
            shift
            ;;
        --update)
            UPDATE_MODE=true
            shift
            ;;
        --no-tmux)
            NO_TMUX_MODE=true
            shift
            ;;
        -h | --help)
            echo "Usage: git worktree-helper [options] <feature-name>"
            echo ""
            echo "Git worktree management with .env.local generation"
            echo ""
            echo "Options:"
            echo "  -h, --help              Show this help message"
            echo "  --init                  Create config file"
            echo "  --list                  List all active worktrees"
            echo "  --install-completions   Install shell completions"
            echo "  --update                Update feature branch with latest from base branch"
            echo "  --clean                 Remove worktree and branch (composable with --merge/--squash)"
            echo "  --merge                 Merge branch into main (no prompts)"
            echo "  --squash                Squash merge branch into main (no prompts)"
            echo ""
            echo "Examples:"
            echo "  git worktree-helper feature-name           # Create worktree"
            echo "  git worktree-helper --update feature-name  # Update feature branch with main"
            echo "  git worktree-helper --merge feature-name   # Merge and keep worktree"
            echo "  git worktree-helper --squash feature-name  # Squash merge and keep worktree"
            echo "  git worktree-helper --merge --clean feat   # Merge and cleanup"
            echo "  git worktree-helper --squash --clean feat  # Squash merge and cleanup"
            echo "  git worktree-helper --clean feature-name   # Just cleanup"
            echo ""
            exit 0
            ;;
        --clean)
            CLEAN_FLAG=true
            shift
            ;;
        --merge)
            MERGE_MODE=true
            shift
            ;;
        -*)
            echo "Unknown option: $1"
            echo "Use -h or --help for more information"
            exit 1
            ;;
        *)
            if [ -z "$FEATURE_NAME" ]; then
                FEATURE_NAME="$1"
            else
                echo "Too many arguments"
                echo "Use -h or --help for more information"
                exit 1
            fi
            shift
            ;;
        esac
    done

    if [ -z "$FEATURE_NAME" ] && [ "$INIT_MODE" != true ] && [ "$LIST_MODE" != true ] && [ "$INSTALL_COMPLETIONS_MODE" != true ]; then
        echo "Error: Feature name is required"
        echo "Use -h or --help for more information"
        exit 1
    fi
}

# Global variables
FEATURE_NAME=""
WORKTREE_DIR=""
GIT_ROOT=""
REPO_NAME=""
PARENT_DIR=""
CLEAN_FLAG=false
MERGE_MODE=false
SQUASH_MODE=false
UPDATE_MODE=false
INIT_MODE=false
LIST_MODE=false
INSTALL_COMPLETIONS_MODE=false
NO_TMUX_MODE=false
FEATURE_VALIDATED=false

# Main
main() {
    if [ "$GIT_WT_TMUX_CHILD" = "1" ] && [ -n "$TMUX" ]; then
        trap 'status=$?; trap - EXIT; keep_tmux_session_alive "$status"' EXIT
    fi

    parse_arguments "$@"
    setup_environment

    # Handle special modes first
    if [ "$INIT_MODE" = true ]; then
        init_config
        exit 0
    fi

    if [ "$INSTALL_COMPLETIONS_MODE" = true ]; then
        install_completions
        exit 0
    fi

    if [ "$LIST_MODE" = true ]; then
        list_worktrees
        exit 0
    fi

    # Handle --update mode
    if [ "$UPDATE_MODE" = true ]; then
        execute_update_operation
        exit 0
    fi

    # Handle --clean only (no merge/squash)
    if [ "$CLEAN_FLAG" = true ] && [ "$MERGE_MODE" = false ] && [ "$SQUASH_MODE" = false ]; then
        echo "üßπ Clean mode: removing worktree for feature '$FEATURE_NAME'"
        validate_existing_feature
        perform_cleanup
        exit 0
    fi

    # Handle --merge or --squash (with optional --clean)
    if [ "$MERGE_MODE" = true ] || [ "$SQUASH_MODE" = true ]; then
        validate_existing_feature

        # Perform the merge
        execute_merge_operation

        # Cleanup if --clean flag is set
        if [ "$CLEAN_FLAG" = true ]; then
            echo ""
            echo "üßπ Cleaning up after merge..."
            perform_cleanup
        else
            echo ""
            print_cleanup_instructions
        fi
        exit 0
    fi

    # Default: Create new worktree
    # Check for existing worktree
    if [ -d "$WORKTREE_DIR" ] || git worktree list | grep -q "$WORKTREE_DIR"; then
        if git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
            handle_existing_feature
        else
            echo "‚ö†Ô∏è  A worktree exists at '$WORKTREE_DIR' but branch '$FEATURE_NAME' is missing."
            if prompt_yes_no "Clean up the incomplete worktree? (Y/n): " "y"; then
                echo "üßπ Cleaning up incomplete worktree..."
                perform_cleanup
                echo "‚úÖ Cleanup complete"
            else
                echo "‚ùå Cancelled"
                exit 0
            fi
        fi
    fi

    # Create new worktree
    setup_worktree
}

# Only run main if not being sourced
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
