#!/bin/bash
set -e

AI_PROVIDER=""
AI_NAME="AI"
OPENAI_SESSION_ID=""
CURSOR_CHAT_ID=""
CLI_AI_PROVIDER=""
ORIGINAL_ARGS=("$@")

# Helper to call git-worktree-helper
call_git_worktree_helper() {
    if ! command -v git-worktree-helper >/dev/null 2>&1; then
        echo "Error: git-worktree-helper not found in PATH"
        exit 1
    fi
    git-worktree-helper "$@"
}

# Reuse utility functions from git-worktree-helper by calling it
prompt_yes_no() {
    local prompt="$1"
    local default="$2"

    while true; do
        printf "%s" "$prompt"
        read -r response

        case "$response" in
        [yY]|[yY][eE][sS])
            return 0
            ;;
        [nN]|[nN][oO])
            return 1
            ;;
        "")
            if [ "$default" = "y" ]; then
                return 0
            else
                return 1
            fi
            ;;
        *)
            echo "Please answer y(es) or n(o)"
            ;;
        esac
    done
}

switch_to_main_branch() {
    local current_branch
    current_branch=$(git symbolic-ref --short HEAD)
    if [ "$current_branch" != "main" ] && [ "$current_branch" != "master" ]; then
        git checkout main 2>/dev/null || git checkout master 2>/dev/null || {
            echo "Error: Could not switch to main/master branch"
            exit 1
        }
    fi
}

remove_branch() {
    if git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
        echo "üåø Removing branch: $FEATURE_NAME"
        git branch -D "$FEATURE_NAME" 2>/dev/null || {
            echo "Warning: Could not remove branch '$FEATURE_NAME'"
        }
    fi
}

sanitize_tmux_component() {
    local value="$1"
    value=$(printf '%s' "${value:-session}" | tr -c '[:alnum:]_-' '-')
    value=$(printf '%s' "$value" | sed -E 's/-+/-/g; s/^-//; s/-$//')
    if [ -z "$value" ]; then
        value="session"
    fi
    printf '%s' "$value"
}

# Print cleanup instructions
print_cleanup_instructions() {
    echo "üìÅ Worktree preserved at: $WORKTREE_DIR"
    echo "üåø Branch '$FEATURE_NAME' available for later work"
    echo ""
    echo "Options:"
    echo "  ai-worktree --continue --ai claude '$FEATURE_NAME'  # Resume with Claude"
    echo "  ai-worktree --continue --ai openai '$FEATURE_NAME'  # Resume with OpenAI"
    echo "  ai-worktree --continue --ai cursor '$FEATURE_NAME'  # Resume with Cursor"
    echo "  git-worktree-helper --update '$FEATURE_NAME'        # Update with latest from main"
    echo "  ai-worktree --merge '$FEATURE_NAME'              # Merge and cleanup"
    echo "  ai-worktree --clean '$FEATURE_NAME'              # Remove worktree and branch"
}

# Install shell completions
install_completions() {
    echo "üîß Installing shell completions for ai-worktree"
    echo ""

    # Detect shell
    local shell_name
    shell_name=$(basename "${SHELL:-bash}")

    case "$shell_name" in
    fish)
        local fish_completions_dir="$HOME/.config/fish/completions"
        local completion_file="$fish_completions_dir/ai-worktree.fish"

        # Create directory if it doesn't exist
        if [ ! -d "$fish_completions_dir" ]; then
            mkdir -p "$fish_completions_dir"
            echo "üìÅ Created directory: $fish_completions_dir"
        fi

        # Check if completion file already exists
        if [ -f "$completion_file" ]; then
            echo "‚ö†Ô∏è  Fish completion file already exists: $completion_file"
            if ! prompt_yes_no "Overwrite existing completion file? (y/N): " "n"; then
                echo "Skipped Fish completions installation"
                return
            fi
        fi

        # Write Fish completion file
        cat > "$completion_file" << 'EOF'
# Fish completion for ai-worktree

# Complete branch names for --clean, --merge, --continue (only existing worktrees/branches)
function __ai_worktree_existing_branches
    # Get branches that have corresponding worktrees
    if git rev-parse --git-dir >/dev/null 2>&1
        set repo_name (basename (git rev-parse --show-toplevel))
        set parent_dir (dirname (git rev-parse --show-toplevel))

        for branch in (git branch --format='%(refname:short)' 2>/dev/null)
            set worktree_dir "$parent_dir/$repo_name-$branch"
            if test -d "$worktree_dir"
                echo $branch
            end
        end
    end
end

# Complete feature names (any valid branch name or new feature name)
function __ai_worktree_all_branches
    if git rev-parse --git-dir >/dev/null 2>&1
        git branch --format='%(refname:short)' 2>/dev/null
    end
end

# Complete AI providers
function __ai_worktree_providers
    echo claude
    echo openai
    echo cursor
end

# Complete options
complete -c ai-worktree -s h -l help -d "Show help message"
complete -c ai-worktree -l init -d "Create template config file"
complete -c ai-worktree -l list -d "List all active ai-worktree sessions"
complete -c ai-worktree -l install-completions -d "Install shell completions"
complete -c ai-worktree -l update -d "Update feature branch with main" -xa "(__ai_worktree_existing_branches)"
complete -c ai-worktree -l clean -d "Remove worktree and branch" -xa "(__ai_worktree_existing_branches)"
complete -c ai-worktree -l merge -d "Skip to merge and cleanup" -xa "(__ai_worktree_existing_branches)"
complete -c ai-worktree -l continue -d "Resume AI session in existing worktree" -xa "(__ai_worktree_existing_branches)"
complete -c ai-worktree -l ai -d "Select AI provider" -xa "(__ai_worktree_providers)"

# Complete feature names for the main argument (when not using special modes)
complete -c ai-worktree -f -n "not __fish_seen_subcommand_from --clean --merge --continue --update --init --list --install-completions" -xa "(__ai_worktree_all_branches)"
EOF

        echo "‚úÖ Installed Fish completions: $completion_file"
        echo ""
        echo "Completions will be available in new Fish shell sessions."
        echo "To use immediately, run: source $completion_file"
        ;;
    bash)
        echo "‚ö†Ô∏è  Bash completions not yet implemented"
        echo "Consider contributing at: https://github.com/your-repo/ai-worktree"
        ;;
    zsh)
        echo "‚ö†Ô∏è  Zsh completions not yet implemented"
        echo "Consider contributing at: https://github.com/your-repo/ai-worktree"
        ;;
    *)
        echo "‚ö†Ô∏è  Shell '$shell_name' not supported for completions"
        echo "Supported shells: fish"
        ;;
    esac
}

# Add AI-specific variables to config
init_config() {
    local config_file="$GIT_ROOT/.config/git-worktree-helper.sh"

    # Config should already exist from git-worktree-helper --init
    if [ ! -f "$config_file" ]; then
        echo "Error: Config file not found. git-worktree-helper --init should have created it."
        exit 1
    fi

    # Check if AI prompts are already in the config
    if grep -q "CLAUDE_INITIAL_PROMPT" "$config_file"; then
        echo "‚úÖ AI prompt variables already present in config"
        return
    fi

    echo "üìù Adding AI provider prompts to config..."

    # Append AI prompts to the end of the config file
    cat >> "$config_file" << 'EOF'

# AI provider initial prompts (used by ai-worktree)
# These are sent to the AI when starting a new session
# Examples:
#   CLAUDE_INITIAL_PROMPT="start a dev server in the background"
#   OPENAI_INITIAL_PROMPT="run tests before coding"
#   CURSOR_INITIAL_PROMPT="open the docs"
CLAUDE_INITIAL_PROMPT=""
OPENAI_INITIAL_PROMPT=""
CURSOR_INITIAL_PROMPT=""
EOF

    echo "‚úÖ Added AI prompt variables to $config_file"
}

# Load configuration from config files
load_config() {
    # Set defaults
    : "${CLAUDE_INITIAL_PROMPT:=}"
    : "${OPENAI_INITIAL_PROMPT:=}"
    : "${CURSOR_INITIAL_PROMPT:=}"

    # Load unified config if it exists
    local config_file="$GIT_ROOT/.config/git-worktree-helper.sh"
    if [ -f "$config_file" ]; then
        echo "üìù Loading config from $config_file"
        set -a
        # shellcheck disable=SC1090
        source "$config_file"
        set +a
    fi
}

# Validate feature name for tmux compatibility
validate_feature_name() {
    # Tmux session names have restrictions:
    # - Can't contain colons (:)
    # - Can't contain dots (.)
    # - Can't contain spaces or most special chars
    # Valid: alphanumeric, hyphens, underscores
    if ! echo "$FEATURE_NAME" | grep -qE '^[a-zA-Z0-9_-]+$'; then
        echo "Error: Feature name '$FEATURE_NAME' is invalid for tmux session names"
        echo "Feature names must contain only: letters, numbers, hyphens (-), and underscores (_)"
        exit 1
    fi
}

# Validate that the requested AI CLI is available
validate_ai_cli() {
    case "$AI_PROVIDER" in
    claude)
        if ! command -v claude >/dev/null 2>&1; then
            echo "Error: Claude CLI 'claude' not found in PATH"
            exit 1
        fi
        ;;
    openai)
        if ! command -v codex >/dev/null 2>&1; then
            echo "Error: OpenAI CLI 'codex' not found in PATH"
            exit 1
        fi
        ;;
    cursor)
        if ! command -v cursor-agent >/dev/null 2>&1; then
            echo "Error: Cursor CLI 'cursor-agent' not found in PATH"
            exit 1
        fi
        ;;
    "")
        echo "Error: AI provider not specified"
        exit 1
        ;;
    *)
        echo "Error: Unsupported AI provider '$AI_PROVIDER'"
        exit 1
        ;;
    esac
}

ensure_tmux_session() {
    if [ -n "$TMUX" ]; then
        if [ -z "$AI_WORKTREE_TMUX_SESSION" ]; then
            AI_WORKTREE_TMUX_SESSION=$(tmux display-message -p '#S' 2>/dev/null || printf 'tmux')
            export AI_WORKTREE_TMUX_SESSION
        fi
        return
    fi

    if [ "$CLEAN_MODE" = true ] || [ "$MERGE_MODE" = true ] || [ "$UPDATE_MODE" = true ] || [ "$INIT_MODE" = true ] || [ "$LIST_MODE" = true ] || [ "$INSTALL_COMPLETIONS_MODE" = true ]; then
        return
    fi

    if ! command -v tmux >/dev/null 2>&1; then
        echo "Error: tmux is required but not installed or not in PATH."
        exit 1
    fi

    local base_name="ai-${FEATURE_NAME:-session}"
    base_name=${base_name//[^a-zA-Z0-9_-]/-}
    local session_name="${base_name}-$$"

    local script_path
    script_path=$(realpath "$0" 2>/dev/null || echo "$0")

    echo "ü™ü Launching tmux session '$session_name' for ai-worktree..."

    # Execute the script in tmux
    exec tmux new-session -s "$session_name" /usr/bin/env AI_WORKTREE_TMUX_CHILD=1 AI_WORKTREE_TMUX_SESSION="$session_name" "$script_path" "${ORIGINAL_ARGS[@]}"
}

set_ai_metadata() {
    case "$AI_PROVIDER" in
    claude)
        AI_NAME="Claude"
        ;;
    openai)
        AI_NAME="OpenAI"
        ;;
    cursor)
        AI_NAME="Cursor"
        ;;
    *)
        AI_NAME="AI"
        ;;
    esac
}

set_cli_provider() {
    local provider="$1"

    if [ -n "$CLI_AI_PROVIDER" ] && [ "$CLI_AI_PROVIDER" != "$provider" ]; then
        echo "Error: Specify only one AI provider (--ai claude|openai|cursor)"
        exit 1
    fi

    CLI_AI_PROVIDER="$provider"
    AI_PROVIDER="$provider"
    set_ai_metadata
}

get_initial_prompt() {
    case "$AI_PROVIDER" in
    claude)
        printf '%s' "${CLAUDE_INITIAL_PROMPT}"
        ;;
    openai)
        printf '%s' "${OPENAI_INITIAL_PROMPT}"
        ;;
    cursor)
        printf '%s' "${CURSOR_INITIAL_PROMPT}"
        ;;
    *)
        printf '%s' ""
        ;;
    esac
}

get_latest_openai_session_id() {
    local history_file="$HOME/.codex/history.jsonl"

    if [ ! -f "$history_file" ]; then
        return
    fi

    tail -n 1 "$history_file" 2>/dev/null | awk -F'"' '/session_id/ {print $4}'
}

update_openai_session_state() {
    if [ "$AI_PROVIDER" != "openai" ]; then
        return
    fi

    local latest_id
    latest_id=$(get_latest_openai_session_id)

    if [ -n "$latest_id" ]; then
        local previous_id="$OPENAI_SESSION_ID"
        OPENAI_SESSION_ID="$latest_id"
        echo "üíæ Stored OpenAI session ID: $OPENAI_SESSION_ID"
        if [ "$OPENAI_SESSION_ID" != "$previous_id" ]; then
            save_session_state
        fi
    else
        echo "‚ö†Ô∏è  Unable to determine OpenAI session ID from history."
    fi
}

update_cursor_session_state() {
    if [ "$AI_PROVIDER" != "cursor" ]; then
        return
    fi

    if [ -z "$CURSOR_CHAT_ID" ]; then
        echo "‚ö†Ô∏è  Cursor chat ID is unknown. Start a session to capture it."
    fi
}

ensure_openai_session_id() {
    if [ -z "$OPENAI_SESSION_ID" ]; then
        OPENAI_SESSION_ID=$(get_latest_openai_session_id)
    fi

    if [ -z "$OPENAI_SESSION_ID" ]; then
        echo "Error: No OpenAI session ID recorded for this worktree."
        echo "Start an OpenAI session first with: ai-worktree --ai openai $FEATURE_NAME"
        exit 1
    fi
}

post_session_update() {
    case "$AI_PROVIDER" in
    openai)
        update_openai_session_state
        ;;
    cursor)
        update_cursor_session_state
        ;;
    esac
}

dispatch_provider_command() {
    local action="$1"
    local initial_prompt="$2"
    local -a cmd

    case "$AI_PROVIDER" in
    claude)
        cmd=("claude")
        if [ "$action" = "resume" ]; then
            cmd+=("--continue")
        fi
        if [ -n "$initial_prompt" ]; then
            if [ "$action" = "resume" ]; then
                echo "üìù Re-injecting Claude initial prompt from config"
            else
                echo "üìù Using Claude initial prompt from config"
            fi
            cmd+=("$initial_prompt")
        fi
        ;;
    openai)
        cmd=("codex" "--full-auto")
        if [ "$action" = "resume" ]; then
            ensure_openai_session_id
            echo "üíæ Resuming OpenAI session: $OPENAI_SESSION_ID"
            cmd+=("resume" "$OPENAI_SESSION_ID")
            if [ -n "$initial_prompt" ]; then
                echo "üìù Re-injecting OpenAI initial prompt from config"
                cmd+=("$initial_prompt")
            fi
        else
            if [ -n "$initial_prompt" ]; then
                echo "üìù Using OpenAI initial prompt from config"
                cmd+=("$initial_prompt")
            fi
        fi
        ;;
    cursor)
        if [ "$action" = "resume" ]; then
            if [ -z "$CURSOR_CHAT_ID" ]; then
                echo "Error: No Cursor chat ID recorded for this worktree."
                echo "Start a Cursor session first with: ai-worktree --ai cursor $FEATURE_NAME"
                exit 1
            fi
            echo "üíæ Resuming Cursor chat: $CURSOR_CHAT_ID"
        else
            ensure_cursor_chat
        fi

        cmd=("cursor-agent" "--resume" "$CURSOR_CHAT_ID")
        if [ -n "$initial_prompt" ]; then
            if [ "$action" = "resume" ]; then
                echo "üìù Re-injecting Cursor initial prompt from config"
            else
                echo "üìù Using Cursor initial prompt from config"
            fi
            cmd+=("$initial_prompt")
        fi
        ;;
    *)
        echo "Error: Unknown AI provider '$AI_PROVIDER'"
        exit 1
        ;;
    esac

    if ! "${cmd[@]}"; then
        handle_ai_exit
    fi
}

ensure_cursor_chat() {
    if [ "$AI_PROVIDER" != "cursor" ]; then
        return
    fi

    if [ -z "$CURSOR_CHAT_ID" ]; then
        echo "üÜï Creating new Cursor chat session..."
        CURSOR_CHAT_ID=$(cursor-agent create-chat 2>/dev/null | tr -d '[:space:]')
        if [ -z "$CURSOR_CHAT_ID" ]; then
            echo "Error: Failed to create Cursor chat session."
            exit 1
        fi
        echo "üíæ Created Cursor chat ID: $CURSOR_CHAT_ID"
        save_session_state
    fi
}

# Rename tmux session based on feature name
rename_tmux_session() {
    local feature_component port_component session_name

    feature_component=$(sanitize_tmux_component "${FEATURE_NAME:-feature}")
    port_component=$(sanitize_tmux_component "${PORT:-noport}")
    session_name="${feature_component}-${port_component}"

    echo "üè∑Ô∏è  Renaming tmux session to: $session_name"
    if ! tmux rename-session "$session_name"; then
        echo "‚ö†Ô∏è  Failed to rename tmux session to '$session_name'. Keeping existing tmux session name."
    fi
}

keep_tmux_session_alive() {
    local exit_status="$1"
    if [ "$AI_WORKTREE_TMUX_CHILD" = "1" ] && [ -n "$TMUX" ]; then
        local session_label shell_path original_status

        session_label="$(tmux display-message -p '#S' 2>/dev/null)"

        if [ -z "$session_label" ]; then
            session_label="${AI_WORKTREE_TMUX_SESSION:-tmux}"
        fi

        if [ "$exit_status" -ne 0 ]; then
            echo "‚ö†Ô∏è  ai-worktree exited with status $exit_status in session '$session_label'."
        else
            echo "‚úÖ ai-worktree finished in session '$session_label'."
        fi
        echo "‚å®Ô∏è  Opening interactive shell; type 'exit' to close the tmux session when you're done."

        shell_path="${SHELL:-/bin/bash}"
        original_status="$exit_status"

        if [ "${AI_WORKTREE_KEEP_RC:-0}" = "1" ]; then
            "$shell_path" -i || true
        else
            case "$(basename "$shell_path")" in
            bash)
                "$shell_path" --noprofile --norc -i || true
                ;;
            zsh)
                "$shell_path" -f -i || true
                ;;
            fish)
                "$shell_path" --private || true
                ;;
            *)
                "$shell_path" -i || true
                ;;
            esac
        fi

        exit "$original_status"
    fi

    exit "$exit_status"
}

# Save session state to .env.local
save_session_state() {
    local env_file="$WORKTREE_DIR/.env.local"

    {
        echo "# Generated by ai-worktree on $(date)"
        echo "PORT=$PORT"
        echo "FEATURE_NAME=$FEATURE_NAME"
        echo "CREATED_AT=$(date +%s)"
        echo "AI_PROVIDER=$AI_PROVIDER"
        if [ -n "$OPENAI_SESSION_ID" ]; then
            echo "OPENAI_SESSION_ID=$OPENAI_SESSION_ID"
        fi
        if [ -n "$CURSOR_CHAT_ID" ]; then
            echo "CURSOR_CHAT_ID=$CURSOR_CHAT_ID"
        fi

        # Add custom environment variables from config
        if [ ${#ENV_VARS[@]} -gt 0 ]; then
            echo ""
            echo "# Custom environment variables"
            for var in "${ENV_VARS[@]}"; do
                echo "$var"
            done
        fi
    } > "$env_file"
}

# Load session state from .env.local
load_session_state() {
    local env_file="$WORKTREE_DIR/.env.local"

    if [ -f "$env_file" ]; then
        echo "üìù Loading session state from $env_file"
        local previous_ai_provider="$AI_PROVIDER"
        set -a
        # shellcheck disable=SC1090
        source "$env_file"
        set +a

        # Explicitly export variables to ensure they're available
        if [ -n "$PORT" ]; then
            export PORT
            echo "üîå Restored PORT: $PORT"
        fi

        if [ -z "$OPENAI_SESSION_ID" ] && [ -n "${CODEX_SESSION_ID:-}" ]; then
            OPENAI_SESSION_ID="$CODEX_SESSION_ID"
        fi

        if [ -n "$OPENAI_SESSION_ID" ]; then
            echo "üíæ Restored OpenAI session ID: $OPENAI_SESSION_ID"
        fi

        if [ -n "$CURSOR_CHAT_ID" ]; then
            echo "üíæ Restored Cursor chat ID: $CURSOR_CHAT_ID"
        fi

        if [ -n "$CLI_AI_PROVIDER" ]; then
            if [ -n "$AI_PROVIDER" ] && [ "$AI_PROVIDER" != "$CLI_AI_PROVIDER" ]; then
                echo "Error: Worktree configured for '$AI_PROVIDER' but '--$CLI_AI_PROVIDER' was requested."
                exit 1
            fi
            AI_PROVIDER="$CLI_AI_PROVIDER"
        elif [ -z "$AI_PROVIDER" ]; then
            AI_PROVIDER="$previous_ai_provider"
        fi

        set_ai_metadata
    fi
}

# install_dependencies - delegated to git-worktree-helper

# Validate environment and initialize globals
setup_environment() {
    # Validate feature name before tmux handling (skip for modes that don't need it)
    if [ "$INIT_MODE" = false ] && [ "$LIST_MODE" = false ] && [ "$INSTALL_COMPLETIONS_MODE" = false ]; then
        validate_feature_name
    fi

    # Start tmux session automatically when required
    ensure_tmux_session

    # Skip git validation for --install-completions
    if [ "$INSTALL_COMPLETIONS_MODE" = true ]; then
        return
    fi

    # Get the current git directory
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: Not in a git repository"
        exit 1
    fi

    if [ "$CLEAN_MODE" = false ] && [ "$MERGE_MODE" = false ] && [ "$INIT_MODE" = false ] && [ "$LIST_MODE" = false ]; then
        validate_ai_cli
    fi

    # Get the root of the git repository
    GIT_ROOT="$(git rev-parse --show-toplevel)"
    REPO_NAME="$(basename "$GIT_ROOT")"
    PARENT_DIR="$(dirname "$GIT_ROOT")"
    if [ -n "$FEATURE_NAME" ]; then
        WORKTREE_DIR="${PARENT_DIR}/${REPO_NAME}-${FEATURE_NAME}"
    fi
}

# run_setup_tasks - delegated to git-worktree-helper

# check_setup_status - delegated to git-worktree-helper

# Create and setup the worktree environment
setup_worktree() {
    echo "üöÄ Creating worktree using git-worktree-helper..."

    # Delegate to git-worktree-helper with --no-tmux (we're already in a tmux session)
    # This handles: worktree creation, PORT generation, .env.local, dependency installation, setup hooks
    call_git_worktree_helper --no-tmux "$FEATURE_NAME"

    # Change to worktree directory
    cd "$WORKTREE_DIR"

    # Load the .env.local that git-worktree-helper created
    if [ -f "$WORKTREE_DIR/.env.local" ]; then
        set -a
        source "$WORKTREE_DIR/.env.local"
        set +a
        export PORT
        echo "üîå Using PORT: $PORT"
    fi

    # Load configuration for AI-specific settings
    load_config

    # Rename our tmux session to include the feature name
    rename_tmux_session

    # Add AI-specific state to .env.local
    save_session_state

    echo "‚úÖ Worktree ready with AI session at: $WORKTREE_DIR"
}

# Run AI with optional initial prompt
run_ai_session() {
    local initial_prompt
    initial_prompt=$(get_initial_prompt)

    dispatch_provider_command "launch" "$initial_prompt"
    post_session_update

    echo ""
    echo "‚úÖ $AI_NAME session completed."
}

# Handle AI exit (error or interruption)
handle_ai_exit() {
    echo ""
    echo "‚ö†Ô∏è  $AI_NAME exited with an error or was interrupted."

    if prompt_yes_no "Do you want to remove the worktree still? (y/N): " "n"; then
        call_git_worktree_helper --clean "$FEATURE_NAME"
        exit 1
    else
        print_cleanup_instructions
        exit 1
    fi
}

# Get merge and cleanup preference from user with menu
get_merge_and_cleanup_choice() {
    # Set up trap to catch Ctrl+C and ESC
    trap 'echo ""; echo "‚ùå Cancelled - preserving worktree"; print_cleanup_instructions; exit 0' INT

    local selected=1
    local options=(
        "Merge + Clean       [DEFAULT] - Merge into main and remove worktree/branch"
        "Squash + Clean                - Squash merge into main and remove worktree/branch"
        "Throw Away                    - Remove worktree and branch without merging"
        "Merge (Keep)                  - Merge into main but keep worktree/branch"
        "Squash (Keep)                 - Squash merge into main but keep worktree/branch"
        "Do Nothing                    - Preserve worktree and branch for later"
    )
    local actions=("merge-clean" "squash-clean" "throw-away" "merge-keep" "squash-keep" "do-nothing")

    # Simple number selection menu
    echo ""
    echo "What would you like to do with branch '$FEATURE_NAME'?"
    echo ""
    for i in "${!options[@]}"; do
        printf "  %d. %s\n" "$((i + 1))" "${options[$i]}"
    done
    echo ""

    while true; do
        printf "Choose an option [1-6] (default=1, ESC or Ctrl+C to cancel): "

        # Read single character or line
        if read -r choice 2>/dev/null; then
            : # Successfully read input
        else
            # Read failed (Ctrl+C or Ctrl+D)
            echo ""
            echo "‚ùå Cancelled - preserving worktree"
            print_cleanup_instructions
            exit 0
        fi

        # Handle ESC key (might come through as empty or special char)
        if [[ "$choice" == $'\x1b' ]] || [[ "$choice" == "q" ]]; then
            echo ""
            echo "‚ùå Cancelled - preserving worktree"
            print_cleanup_instructions
            exit 0
        fi

        # Handle empty input (Enter key) - default to option 1
        if [ -z "$choice" ]; then
            selected=1
            break
        fi

        # Validate input
        if [[ "$choice" =~ ^[1-6]$ ]]; then
            selected=$choice
            break
        else
            echo "Invalid choice. Please enter a number from 1 to 6."
        fi
    done

    # Set the action based on selection
    merge_action="${actions[$((selected - 1))]}"

    # Reset trap
    trap - INT
}

# execute_merge - delegated to git-worktree-helper
# Note: Merge logic is in git-worktree-helper, but ai-worktree needs to call it with proper context
execute_merge() {
    local merge_type="$1"  # "merge" or "squash"

    # Delegate to git-worktree-helper for merge
    # Note: git-worktree-helper --merge handles the full merge flow
    call_git_worktree_helper --merge "$FEATURE_NAME"
}

# Execute continue operation (resume AI session)
execute_continue_operation() {
    echo "üîÑ Continue mode: resuming $AI_NAME session for feature '$FEATURE_NAME'"

    # Validate that worktree/branch exists
    validate_existing_feature

    # Change to worktree directory
    echo "üìÇ Switching to existing worktree directory..."
    cd "$WORKTREE_DIR"

    # Load configuration to get provider-specific initial prompts
    load_config

    # Load session state (PORT)
    load_session_state

    # Rename tmux session to feature name
    rename_tmux_session

    # Launch AI in resume mode and re-inject initial prompt
    local initial_prompt
    initial_prompt=$(get_initial_prompt)

    echo "üöÄ Resuming $AI_NAME session..."
    dispatch_provider_command "resume" "$initial_prompt"
    post_session_update

    # Post-AI processing
    echo ""
    echo "‚úÖ $AI_NAME session completed."

    # Handle merge and cleanup
    handle_merge_and_cleanup
}

# Execute merge operation (skip to merge and cleanup)
execute_merge_operation() {
    echo "üîÄ Merge mode: skipping to merge and cleanup for feature '$FEATURE_NAME'"

    # Validate that worktree/branch exists
    validate_existing_feature

    # Jump to post-AI processing (merge and cleanup logic)
    # Note: Process killing happens in async cleanup, not here
    echo ""
    echo "‚úÖ Starting merge process for feature '$FEATURE_NAME'"

    # Handle merge and cleanup
    handle_merge_and_cleanup
}

# Execute clean operation (remove worktree and branch)
execute_clean_operation() {
    # Delegate to git-worktree-helper for actual worktree cleanup
    # (it will clean up .env.local which contains AI state)
    call_git_worktree_helper --clean "$FEATURE_NAME"
}

# Execute update operation (merge base branch into feature branch)
execute_update_operation() {
    # Delegate to git-worktree-helper to update the feature branch
    call_git_worktree_helper --update "$FEATURE_NAME"
}

# Handle existing feature detection and user choice
handle_existing_feature() {
    echo "‚ö†Ô∏è  A worktree for '$FEATURE_NAME' already exists at: $WORKTREE_DIR"
    echo ""
    echo "What would you like to do?"
    echo "  1. Continue working on the feature (resume AI session)"
    echo "  2. Merge and cleanup the feature"
    echo "  3. Clean up the feature (remove worktree and branch)"
    echo "  4. Clean up and restart (remove and create fresh worktree)"
    echo "  5. Cancel (preserve existing worktree)"
    echo ""

    while true; do
        printf "Choose an option (1-5): "
        read -r choice

        case "$choice" in
        1)
            execute_continue_operation
            exit 0
            ;;
        2)
            execute_merge_operation
            exit 0
            ;;
        3)
            execute_clean_operation
            exit 0
            ;;
        4)
            # Clean up and restart
            echo ""
            echo "‚Üí Cleaning up and restarting with fresh worktree..."
            call_git_worktree_helper --clean "$FEATURE_NAME"
            echo ""
            echo "‚úÖ Cleanup complete. Creating fresh worktree..."
            # Don't exit - continue to create new worktree and run AI session
            return
            ;;
        5)
            echo "‚ùå Cancelled - existing worktree preserved at: $WORKTREE_DIR"
            print_cleanup_instructions
            exit 0
            ;;
        *)
            echo "Invalid choice. Please enter 1, 2, 3, 4, or 5."
            ;;
        esac
    done
}

# Handle merge and cleanup flow
handle_merge_and_cleanup() {
    # Get user's choice from menu
    get_merge_and_cleanup_choice

    case "$merge_action" in
    merge-clean)
        echo ""
        echo "‚Üí Merging and cleaning up..."
        # Use composable flags: --merge --clean
        call_git_worktree_helper --merge --clean "$FEATURE_NAME"
        ;;
    squash-clean)
        echo ""
        echo "‚Üí Squash merging and cleaning up..."
        # Use composable flags: --squash --clean
        call_git_worktree_helper --squash --clean "$FEATURE_NAME"
        ;;
    throw-away)
        echo ""
        echo "‚Üí Throwing away changes and cleaning up..."
        call_git_worktree_helper --clean "$FEATURE_NAME"
        ;;
    merge-keep)
        echo ""
        echo "‚Üí Merging and keeping worktree..."
        call_git_worktree_helper --merge "$FEATURE_NAME"
        echo ""
        echo "‚úÖ Merge complete. Worktree and branch preserved."
        print_cleanup_instructions
        ;;
    squash-keep)
        echo ""
        echo "‚Üí Squash merging and keeping worktree..."
        # Use --squash alone to squash merge and keep worktree
        call_git_worktree_helper --squash "$FEATURE_NAME"
        echo ""
        echo "‚úÖ Squash merge complete. Worktree and branch preserved."
        print_cleanup_instructions
        ;;
    do-nothing)
        echo ""
        echo "‚Üí Doing nothing - preserving worktree and branch"
        print_cleanup_instructions
        ;;
    *)
        echo "Error: Unknown merge action '$merge_action'"
        exit 1
        ;;
    esac
}

# Validate that worktree and branch exist for modes that require them
validate_existing_feature() {
    # Skip if we've already validated
    if [ "$FEATURE_VALIDATED" = true ]; then
        return
    fi

    # Check if worktree exists
    if [ ! -d "$WORKTREE_DIR" ] && ! git worktree list | grep -q "$WORKTREE_DIR"; then
        echo "Error: No worktree found for feature '$FEATURE_NAME' at: $WORKTREE_DIR"
        exit 1
    fi

    # Check if branch exists
    if ! git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
        echo "Error: Branch '$FEATURE_NAME' does not exist"
        exit 1
    fi

    # Mark as validated
    FEATURE_VALIDATED=true
}

# Cleanup is delegated to git-worktree-helper

# List all ai-worktree sessions
list_worktrees() {
    echo "üîç Active ai-worktree sessions:"
    echo ""

    local found_any=false
    local git_root
    git_root="$(git rev-parse --show-toplevel 2>/dev/null)"

    if [ -z "$git_root" ]; then
        echo "Error: Not in a git repository"
        exit 1
    fi

    # Get all worktrees for this repo (using process substitution to avoid subshell)
    while IFS= read -r line; do
        if [[ "$line" =~ ^worktree ]]; then
            local worktree_path="${line#worktree }"
            local branch="" commit="" provider="" port="" setup_status=""

            # Read additional lines for this worktree
            while IFS= read -r info_line; do
                if [[ "$info_line" =~ ^branch ]]; then
                    branch="${info_line#branch refs/heads/}"
                elif [[ "$info_line" =~ ^HEAD ]]; then
                    commit="${info_line#HEAD }"
                    commit="${commit:0:7}"
                elif [[ -z "$info_line" ]]; then
                    # Empty line indicates end of this worktree entry
                    break
                fi
            done

            # Check if this is an ai-worktree session (has AI_PROVIDER in .env.local)
            if [ -f "$worktree_path/.env.local" ]; then
                # Load session state to check if it's an AI worktree
                AI_PROVIDER=""
                PORT=""
                if [ -r "$worktree_path/.env.local" ]; then
                    # shellcheck disable=SC1090
                    source "$worktree_path/.env.local" 2>/dev/null || true
                fi

                # Only list if it has AI_PROVIDER set
                if [ -n "$AI_PROVIDER" ]; then
                    found_any=true
                    provider="$AI_PROVIDER"
                    port="$PORT"
                else
                    # Not an AI worktree, skip it
                    continue
                fi

                # Check setup status
                if [ -f "$worktree_path/.git-worktree-helper/setup.pid" ]; then
                    local setup_pid
                    setup_pid=$(cat "$worktree_path/.git-worktree-helper/setup.pid" 2>/dev/null)
                    if [ -n "$setup_pid" ] && kill -0 "$setup_pid" 2>/dev/null; then
                        setup_status="‚öôÔ∏è  (setup running)"
                    elif [ -f "$worktree_path/.git-worktree-helper/setup.log" ] && grep -q "‚úÖ Setup tasks completed" "$worktree_path/.git-worktree-helper/setup.log" 2>/dev/null; then
                        setup_status="‚úÖ (setup complete)"
                    else
                        setup_status="‚ö†Ô∏è  (setup status unknown)"
                    fi
                else
                    setup_status="‚úÖ (ready)"
                fi

                # Display the worktree info
                echo "üìÅ Branch: $branch"
                echo "   Path: $worktree_path"
                echo "   Provider: ${provider:-unknown}"
                echo "   Port: ${port:-none}"
                echo "   Status: $setup_status"

                # Show session IDs if available
                if [ -n "$OPENAI_SESSION_ID" ] && [ "$provider" = "openai" ]; then
                    echo "   OpenAI Session: $OPENAI_SESSION_ID"
                fi
                if [ -n "$CURSOR_CHAT_ID" ] && [ "$provider" = "cursor" ]; then
                    echo "   Cursor Chat: $CURSOR_CHAT_ID"
                fi

                echo ""
            fi
        fi
    done < <(git worktree list --porcelain)

    if [ "$found_any" = false ]; then
        echo "No active ai-worktree sessions found."
        echo ""
        echo "Create one with: ai-worktree --ai <claude|openai|cursor> <feature-name>"
    fi

    # Check for running cleanup operations
    local cleanup_dir="$git_root/.ai-worktree/cleanups"
    if [ -d "$cleanup_dir" ]; then
        local found_cleanups=false

        for pid_file in "$cleanup_dir"/*.pid; do
            [ -e "$pid_file" ] || continue

            local cleanup_pid
            cleanup_pid=$(cat "$pid_file" 2>/dev/null)

            if [ -n "$cleanup_pid" ] && kill -0 "$cleanup_pid" 2>/dev/null; then
                if [ "$found_cleanups" = false ]; then
                    echo ""
                    echo "üßπ Running cleanup operations:"
                    echo ""
                    found_cleanups=true
                fi

                local cleanup_id
                cleanup_id=$(basename "$pid_file" .pid)
                local feature_name="${cleanup_id%%-*}"
                local log_file="$cleanup_dir/${cleanup_id}.log"

                echo "üîÑ Feature: $feature_name"
                echo "   PID: $cleanup_pid"
                echo "   Log: $log_file"

                # Show last few lines of log if available
                if [ -f "$log_file" ] && [ -r "$log_file" ]; then
                    local last_line
                    last_line=$(tail -n 1 "$log_file" 2>/dev/null)
                    if [ -n "$last_line" ]; then
                        echo "   Status: $last_line"
                    fi
                fi
                echo ""
            else
                # PID file exists but process is dead, clean it up
                rm -f "$pid_file" 2>/dev/null || true
            fi
        done

        # Clean up old log files (older than 7 days)
        find "$cleanup_dir" -name "*.log" -mtime +7 -delete 2>/dev/null || true
    fi
}

# Parse command line arguments
parse_arguments() {
    CLEAN_MODE=false
    MERGE_MODE=false
    CONTINUE_MODE=false
    UPDATE_MODE=false
    INIT_MODE=false
    LIST_MODE=false
    INSTALL_COMPLETIONS_MODE=false
    FEATURE_NAME=""
    AI_PROVIDER=""
    CLI_AI_PROVIDER=""

    while [ $# -gt 0 ]; do
        case $1 in
        --init)
            INIT_MODE=true
            shift
            ;;
        --install-completions)
            INSTALL_COMPLETIONS_MODE=true
            shift
            ;;
        --list)
            LIST_MODE=true
            shift
            ;;
        --ai)
            if [ $# -lt 2 ]; then
                echo "Error: --ai requires a provider (claude, openai, cursor)"
                exit 1
            fi
            local provider_arg
            provider_arg=$(printf '%s' "$2" | tr '[:upper:]' '[:lower:]')
            case "$provider_arg" in
            claude | openai | cursor)
                set_cli_provider "$provider_arg"
                ;;
            *)
                echo "Error: Unknown provider '$2'. Supported providers: claude, openai, cursor."
                exit 1
                ;;
            esac
            shift 2
            ;;
        -h | --help)
            echo "Usage: ai-worktree --ai <claude|openai|cursor> [options] <feature-name>"
            echo ""
            echo "Git worktree with AI assistant integration"
            echo ""
            echo "Options:"
            echo "  -h, --help              Show this help message"
            echo "  --init                  Create config file"
            echo "  --list                  List all active sessions"
            echo "  --install-completions   Install shell completions"
            echo "  --update                Update feature branch with latest from main"
            echo "  --clean                 Remove worktree and branch"
            echo "  --merge                 Merge and cleanup"
            echo "  --continue              Resume AI session"
            echo "  --ai <name>             Select provider (claude, openai, cursor)"
            echo ""
            exit 0
            ;;
        --clean)
            CLEAN_MODE=true
            shift
            ;;
        --merge)
            MERGE_MODE=true
            shift
            ;;
        --continue)
            CONTINUE_MODE=true
            shift
            ;;
        --update)
            UPDATE_MODE=true
            shift
            ;;
        -*)
            echo "Unknown option: $1"
            echo "Use -h or --help for more information"
            exit 1
            ;;
        *)
            if [ -z "$FEATURE_NAME" ]; then
                FEATURE_NAME="$1"
            else
                echo "Too many arguments"
                echo "Use -h or --help for more information"
                exit 1
            fi
            shift
            ;;
        esac
    done

    # Check if feature name is provided (not required for --init, --list, or --install-completions)
    if [ -z "$FEATURE_NAME" ] && [ "$INIT_MODE" != true ] && [ "$LIST_MODE" != true ] && [ "$INSTALL_COMPLETIONS_MODE" != true ]; then
        echo "Error: Feature name is required."
        echo "Use -h or --help for more information"
        exit 1
    fi

    # Require AI provider for modes that launch a session
    if [ "$INIT_MODE" = false ] && [ "$CLEAN_MODE" = false ] && [ "$MERGE_MODE" = false ] && [ "$UPDATE_MODE" = false ] && [ "$LIST_MODE" = false ] && [ "$INSTALL_COMPLETIONS_MODE" = false ]; then
        if [ -z "$AI_PROVIDER" ]; then
            echo "Error: Specify an AI provider with '--ai claude|openai|cursor'."
            exit 1
        fi
    fi
}

# Kill all processes in worktree directory except ai-worktree script
kill_worktree_processes() {
    # Skip if we've already killed processes
    if [ "$PROCESSES_KILLED" = true ]; then
        return
    fi

    if [ ! -d "$WORKTREE_DIR" ]; then
        return
    fi

    echo "üî™ Killing processes in worktree directory..."
    PROCESSES_KILLED=true

    # Kill background setup process if it's still running
    local setup_pid_file="$WORKTREE_DIR/.ai-worktree/setup.pid"
    if [ -f "$setup_pid_file" ]; then
        local setup_pid
        setup_pid=$(cat "$setup_pid_file" 2>/dev/null)
        if [ -n "$setup_pid" ] && kill -0 "$setup_pid" 2>/dev/null; then
            echo "  Killing background setup process (PID $setup_pid)"
            kill "$setup_pid" 2>/dev/null || true
            sleep 0.1
            kill -9 "$setup_pid" 2>/dev/null || true
        fi
        rm -f "$setup_pid_file"
    fi

    # Get our script info for exclusion
    script_pid=$$
    script_name=$(basename "$0")
    script_real_path=$(realpath "$0" 2>/dev/null || echo "$0")

    # Get all processes using files in the worktree directory (with timeout)
    # Use timeout command if available, otherwise use a background job with timeout
    if command -v timeout >/dev/null 2>&1; then
        # GNU timeout or compatible
        pids=$(timeout 5 lsof +D "$WORKTREE_DIR" 2>/dev/null | awk 'NR>1 {print $2}' | sort -u || true)
    elif command -v gtimeout >/dev/null 2>&1; then
        # GNU timeout on macOS (from coreutils)
        pids=$(gtimeout 5 lsof +D "$WORKTREE_DIR" 2>/dev/null | awk 'NR>1 {print $2}' | sort -u || true)
    else
        # Fallback: run lsof with manual timeout
        pids=$(
            {
                lsof +D "$WORKTREE_DIR" 2>/dev/null | awk 'NR>1 {print $2}' | sort -u &
                lsof_pid=$!
                sleep 5
                if kill -0 "$lsof_pid" 2>/dev/null; then
                    kill "$lsof_pid" 2>/dev/null || true
                fi
            } || true
        )
    fi

    for pid in $pids; do
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            # Skip our own process and any parent processes
            if [ "$pid" = "$script_pid" ]; then
                echo "  Skipping ai-worktree script (PID $pid)"
                continue
            fi

            # Check if this PID is in our process tree
            current_ppid=$script_pid
            while [ "$current_ppid" -gt 1 ]; do
                if [ "$pid" = "$current_ppid" ]; then
                    echo "  Skipping parent process (PID $pid)"
                    continue 2
                fi
                current_ppid=$(ps -o ppid= -p "$current_ppid" 2>/dev/null | tr -d ' ')
                [ -z "$current_ppid" ] && break
            done

            # Get process info
            process_cmd=$(ps -p "$pid" -o args= 2>/dev/null || echo "unknown")
            process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unknown")

            # Enhanced exclusion checks for ai-worktree related processes
            case "$process_cmd" in
            *"ai-worktree"* | *"$script_name"* | *"$script_real_path"*)
                echo "  Skipping ai-worktree process $pid: $process_cmd"
                continue
                ;;
            esac

            # Skip shell processes that might be running this script
            case "$process_name" in
            "bash" | "sh" | "zsh" | "fish")
                # Check if the shell is running an ai-worktree command
                if echo "$process_cmd" | grep -q "ai-worktree"; then
                    echo "  Skipping shell running ai-worktree $pid: $process_cmd"
                    continue
                fi
                ;;
            esac

            # Skip tmux processes
            if [ "$process_name" = "tmux" ]; then
                echo "  Skipping tmux process $pid: $process_cmd"
                continue
            fi
            if echo "$process_cmd" | grep -q "tmux"; then
                echo "  Skipping tmux process $pid: $process_cmd"
                continue
            fi

            # Skip unknown processes for safety
            if [ "$process_name" = "unknown" ] || [ "$process_cmd" = "unknown" ]; then
                echo "  Skipping unknown process $pid"
                continue
            fi

            echo "  Killing process $pid ($process_name): $process_cmd"
            # Use SIGTERM first, then SIGKILL if needed
            if kill "$pid" 2>/dev/null; then
                # Wait a moment and check if process is still running
                sleep 0.1
                if kill -0 "$pid" 2>/dev/null; then
                    kill -9 "$pid" 2>/dev/null
                fi
            fi
        fi
    done
}

# Global variables - set during script execution
FEATURE_NAME=""                # Name of the feature branch being worked on
WORKTREE_DIR=""                # Path to the worktree directory
GIT_ROOT=""                    # Root directory of the git repository
REPO_NAME=""                   # Name of the repository
PARENT_DIR=""                  # Parent directory containing the repository
CLEAN_MODE=false               # Whether script is running in cleanup mode
MERGE_MODE=false               # Whether script is running in merge mode
CONTINUE_MODE=false            # Whether script is running in continue mode
UPDATE_MODE=false              # Whether script is running in update mode
INIT_MODE=false                # Whether script is running in init mode
LIST_MODE=false                # Whether script is running in list mode
INSTALL_COMPLETIONS_MODE=false # Whether script is running in install-completions mode
PROCESSES_KILLED=false         # Whether we've already killed worktree processes
FEATURE_VALIDATED=false        # Whether we've already validated the existing feature

# Main execution function
main() {
    if [ "$AI_WORKTREE_TMUX_CHILD" = "1" ] && [ -n "$TMUX" ]; then
        trap 'status=$?; trap - EXIT; keep_tmux_session_alive "$status"' EXIT
    fi

    # Parse arguments and validate environment
    parse_arguments "$@"
    setup_environment

    # Handle init mode if requested (exit early)
    if [ "$INIT_MODE" = true ]; then
        # Use git-worktree-helper to create base config, then add AI prompts
        call_git_worktree_helper --init
        init_config
        exit 0
    fi

    # Handle install-completions mode if requested (exit early)
    if [ "$INSTALL_COMPLETIONS_MODE" = true ]; then
        install_completions
        exit 0
    fi

    # Handle list mode if requested (exit early)
    if [ "$LIST_MODE" = true ]; then
        list_worktrees
        exit 0
    fi

    # Handle clean mode if requested (exit early)
    if [ "$CLEAN_MODE" = true ]; then
        execute_clean_operation
        exit 0
    fi

    # Handle update mode if requested (update feature branch with main)
    if [ "$UPDATE_MODE" = true ]; then
        execute_update_operation
        exit 0
    fi

    # Handle merge mode if requested (skip to merge and cleanup logic)
    if [ "$MERGE_MODE" = true ]; then
        execute_merge_operation
        exit 0
    fi

    # Handle continue mode if requested (resume AI in existing worktree)
    if [ "$CONTINUE_MODE" = true ]; then
        execute_continue_operation
        exit 0
    fi

    # Check for existing worktree before creating
    if [ -d "$WORKTREE_DIR" ] || git worktree list | grep -q "$WORKTREE_DIR"; then
        # Validate that the existing feature is complete (worktree and branch exist)
        if git show-ref --verify --quiet refs/heads/"$FEATURE_NAME"; then
            handle_existing_feature
        else
            # Worktree exists but branch is missing - offer cleanup only
            echo "‚ö†Ô∏è  A worktree exists at '$WORKTREE_DIR' but branch '$FEATURE_NAME' is missing."
            if prompt_yes_no "Clean up the incomplete worktree? (Y/n): " "y"; then
                echo "üßπ Cleaning up incomplete worktree..."
                call_git_worktree_helper --clean "$FEATURE_NAME"
                echo "‚úÖ Incomplete worktree cleaned up"
            else
                echo "‚ùå Cancelled - incomplete worktree preserved"
                exit 0
            fi
        fi
    fi

    # Create worktree and setup environment (localias setup is now included)
    setup_worktree

    # Run AI session
    run_ai_session

    # Handle merge and cleanup
    handle_merge_and_cleanup
}

# Execute main function with all arguments
main "$@"
