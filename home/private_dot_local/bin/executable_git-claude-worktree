#!/bin/sh
set -e

# Show help if requested
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    echo "Usage: $0 <feature-name>"
    echo ""
    echo "Creates a git worktree for feature development with Claude"
    echo ""
    echo "Arguments:"
    echo "  feature-name    Name of the feature branch to create"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo ""
    echo "The script will:"
    echo "  1. Create a worktree in a sibling directory"
    echo "  2. Create or checkout the feature branch"
    echo "  3. Install dependencies if package files are found"
    echo "  4. Set terminal/window title"
    echo "  5. Launch Claude with --trust flag"
    echo "  6. After Claude exits, offer to merge and cleanup"
    exit 0
fi

# Check if feature name is provided
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <feature-name>"
    echo "Use -h or --help for more information"
    exit 1
fi

FEATURE_NAME="$1"

# Get the current git directory
if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "Error: Not in a git repository"
    exit 1
fi

# Get the root of the git repository
GIT_ROOT="$(git rev-parse --show-toplevel)"
REPO_NAME="$(basename "$GIT_ROOT")"
PARENT_DIR="$(dirname "$GIT_ROOT")"

# Create worktree directory path
WORKTREE_DIR="${PARENT_DIR}/${REPO_NAME}-${FEATURE_NAME}"

# Create the worktree
echo "üìÅ Creating worktree at: $WORKTREE_DIR"
echo "üåø Branch: $FEATURE_NAME"
git worktree add "$WORKTREE_DIR" -b "$FEATURE_NAME" 2>/dev/null || git worktree add "$WORKTREE_DIR" "$FEATURE_NAME"


# Change to worktree directory and run claude
echo "üìÇ Switching to worktree directory..."
cd "$WORKTREE_DIR"

# Auto-install dependencies if package files exist
auto_install_deps() {
    if [ -f "package.json" ]; then
        if command -v npm >/dev/null 2>&1; then
            echo "üì¶ Installing npm dependencies..."
            npm install
        fi
    elif [ -f "yarn.lock" ] && [ -f "package.json" ]; then
        if command -v yarn >/dev/null 2>&1; then
            echo "üß∂ Installing yarn dependencies..."
            yarn install
        fi
    elif [ -f "Cargo.toml" ]; then
        if command -v cargo >/dev/null 2>&1; then
            echo "ü¶Ä Building Rust project..."
            cargo build
        fi
    elif [ -f "requirements.txt" ]; then
        if command -v pip >/dev/null 2>&1; then
            echo "üêç Installing Python dependencies..."
            pip install -r requirements.txt
        fi
    elif [ -f "Gemfile" ]; then
        if command -v bundle >/dev/null 2>&1; then
            echo "üíé Installing Ruby dependencies..."
            bundle install
        fi
    fi
}

auto_install_deps

# Set terminal/window title
set_terminal_title() {
    local title="$1"
    
    # tmux
    if [ -n "$TMUX" ]; then
        tmux rename-window "$title"
    fi
    
    # iTerm2, Terminal.app, and other terminals that support OSC sequences
    case "$TERM_PROGRAM" in
        "iTerm.app"|"Apple_Terminal")
            printf "\033]0;%s\007" "$title"
            ;;
        *)
            # Generic terminal title setting (works with most modern terminals)
            printf "\033]2;%s\033\\" "$title"
            ;;
    esac
    
    # GNU Screen
    if [ -n "$STY" ]; then
        screen -X title "$title"
    fi
}

set_terminal_title "${REPO_NAME}-${FEATURE_NAME}"

# Launch Claude with error recovery
launch_claude() {
    if ! claude; then
        echo ""
        echo "‚ö†Ô∏è  Claude exited with an error or was interrupted."
        
        while true; do
            printf "Continue with merge/cleanup options anyway? (y/N): "
            read -r continue_response
            
            case "$continue_response" in
            [yY] | [yY][eE][sS])
                break
                ;;
            [nN] | [nN][oO] | "")
                echo "üìÅ Worktree preserved at: $WORKTREE_DIR"
                echo "üåø Branch '$FEATURE_NAME' available for later work"
                echo "üßπ To clean up later: git worktree remove '$WORKTREE_DIR' && git branch -d '$FEATURE_NAME'"
                exit 0
                ;;
            *)
                echo "Please answer y(es) or n(o)"
                ;;
            esac
        done
    fi
}

# Check if we're already in tmux
if [ -z "$TMUX" ]; then
    # Not in tmux, start a new session
    echo "üñ•Ô∏è  Starting tmux session: ${REPO_NAME}-${FEATURE_NAME}"
    exec tmux new-session -d -s "${REPO_NAME}-${FEATURE_NAME}" -c "$WORKTREE_DIR" \; send-keys "claude" Enter \; attach
else
    # Already in tmux, just launch claude
    launch_claude
fi

# After claude exits, ask about merging and cleanup
echo ""
echo "‚úÖ Claude session completed."

# Ask about merging first
while true; do
    printf "Merge branch '$FEATURE_NAME' into main? (Y=squash, m=merge, n=no): "
    read -r merge_response
    
    case "$merge_response" in
    [yY] | [yY][eE][sS] | "")
        merge_type="squash"
        break
        ;;
    [mM] | [mM][eE][rR][gG][eE])
        merge_type="merge"
        break
        ;;
    [nN] | [nN][oO])
        merge_type="no"
        break
        ;;
    *)
        echo "Please answer Y (squash), m (merge), or n (no)"
        ;;
    esac
done

# Handle merging
if [ "$merge_type" != "no" ]; then
    # Go back to original repo to merge
    cd "$GIT_ROOT"

    # Check if we're on main/master
    current_branch=$(git symbolic-ref --short HEAD)
    if [ "$current_branch" != "main" ] && [ "$current_branch" != "master" ]; then
        # Try to switch to main, fall back to master
        git checkout main 2>/dev/null || git checkout master 2>/dev/null || {
            echo "Error: Could not switch to main/master branch"
            exit 1
        }
    fi

    if [ "$merge_type" = "squash" ]; then
        echo "üîÑ Squash merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --squash "$FEATURE_NAME"; then
            # Commit the squashed changes (opens editor)
            if git commit; then
                echo "‚úÖ Squash merge successful!"
                merge_successful=true
            else
                echo "Commit cancelled or failed."
                echo "Worktree preserved at: $WORKTREE_DIR"
                echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
                exit 1
            fi
        else
            echo "Squash merge conflicts detected. Please resolve them manually."
            echo "Worktree preserved at: $WORKTREE_DIR"
            echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
            exit 1
        fi
    else
        echo "üîÄ Merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge "$FEATURE_NAME"; then
            echo "‚úÖ Merge successful!"
            merge_successful=true
        else
            echo "Merge conflicts detected. Please resolve them manually."
            echo "Worktree preserved at: $WORKTREE_DIR"
            echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
            exit 1
        fi
    fi

    # Offer to push to remote after successful merge
    if [ "$merge_successful" = true ]; then
        printf "Push changes to remote? (y/N): "
        read -r push_response
        case "$push_response" in
        [yY] | [yY][eE][sS])
            current_branch=$(git symbolic-ref --short HEAD)
            echo "üöÄ Pushing $current_branch to remote..."
            git push
            ;;
        esac
    fi

    # Automatic cleanup after successful merge
    # Check for unstaged changes in the worktree
    cd "$WORKTREE_DIR"
    if ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
        echo "Warning: The worktree has unstaged changes, staged changes, or untracked files."
        git status --short
        
        while true; do
            printf "Force remove the worktree anyway? (y/N): "
            read -r force_response
            
            case "$force_response" in
            [yY] | [yY][eE][sS])
                force_remove=true
                break
                ;;
            [nN] | [nN][oO] | "")
                echo "Worktree preserved at: $WORKTREE_DIR"
                echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
                exit 0
                ;;
            *)
                echo "Please answer y(es) or n(o)"
                ;;
            esac
        done
    fi

    # Go back to original repo for cleanup
    cd "$GIT_ROOT"

    # Delete the branch
    echo "üóëÔ∏è  Deleting branch '$FEATURE_NAME'..."
    git branch -d "$FEATURE_NAME"

    # Remove the worktree
    echo "üßπ Removing worktree at '$WORKTREE_DIR'..."
    if [ "$force_remove" = true ]; then
        git worktree remove --force "$WORKTREE_DIR"
    else
        git worktree remove "$WORKTREE_DIR"
    fi

    echo "‚ú® Cleanup complete!"
else
    echo "Skipping merge."
    
    # Ask about cleanup only if no merge
    while true; do
        printf "Do you want to delete the worktree and branch '$FEATURE_NAME'? (y/N): "
        read -r cleanup_response
        
        case "$cleanup_response" in
        [yY] | [yY][eE][sS])
            cleanup_response="y"
            break
            ;;
        [nN] | [nN][oO] | "")
            cleanup_response="n"
            break
            ;;
        *)
            echo "Please answer y(es) or n(o)"
            ;;
        esac
    done

    # Handle cleanup
    if [ "$cleanup_response" = "y" ]; then
        # Check for unstaged changes in the worktree
        cd "$WORKTREE_DIR"
        if ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
            echo "Warning: The worktree has unstaged changes, staged changes, or untracked files."
            git status --short
            
            while true; do
                printf "Force remove the worktree anyway? (y/N): "
                read -r force_response
                
                case "$force_response" in
                [yY] | [yY][eE][sS])
                    force_remove=true
                    break
                    ;;
                [nN] | [nN][oO] | "")
                    echo "Worktree preserved at: $WORKTREE_DIR"
                    echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
                    exit 0
                    ;;
                *)
                    echo "Please answer y(es) or n(o)"
                    ;;
                esac
            done
        fi

        # Go back to original repo for cleanup
        cd "$GIT_ROOT"

        # Remove the worktree
        echo "üßπ Removing worktree at '$WORKTREE_DIR'..."
        if [ "$force_remove" = true ]; then
            git worktree remove --force "$WORKTREE_DIR"
        else
            git worktree remove "$WORKTREE_DIR"
        fi

        echo "‚ú® Cleanup complete!"
    else
        echo "Worktree preserved at: $WORKTREE_DIR"
        echo "To merge later: git merge '$FEATURE_NAME'"
        echo "To clean up later: git worktree remove '$WORKTREE_DIR' && git branch -d '$FEATURE_NAME'"
    fi
fi
