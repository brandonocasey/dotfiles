#!/bin/sh
set -e

# Check if feature name is provided
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <feature-name>"
    exit 1
fi

FEATURE_NAME="$1"

# Get the current git directory
if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "Error: Not in a git repository"
    exit 1
fi

# Get the root of the git repository
GIT_ROOT="$(git rev-parse --show-toplevel)"
REPO_NAME="$(basename "$GIT_ROOT")"
PARENT_DIR="$(dirname "$GIT_ROOT")"

# Create worktree directory path
WORKTREE_DIR="${PARENT_DIR}/${REPO_NAME}-${FEATURE_NAME}"

# Create the worktree
echo "Creating worktree at: $WORKTREE_DIR"
git worktree add "$WORKTREE_DIR" -b "$FEATURE_NAME" 2>/dev/null || git worktree add "$WORKTREE_DIR" "$FEATURE_NAME"


# Change to worktree directory and run claude
echo "Launching claude in worktree..."
cd "$WORKTREE_DIR"

# Run worktree setup script if it exists
if [ -f "scripts/worktree-setup" ]; then
    if [ -x "scripts/worktree-setup" ]; then
        echo "Running worktree setup script..."
        ./scripts/worktree-setup
    else
        echo "Warning: scripts/worktree-setup exists but is not executable"
    fi
fi

# Rename tmux window if we're in one
if [ -n "$TMUX" ]; then
    tmux rename-window "${REPO_NAME}-${FEATURE_NAME}"
fi

claude

# After claude exits, ask about merging and cleanup
echo ""
echo "Claude session ended."

# Ask about merging first
while true; do
    printf "Merge branch '$FEATURE_NAME' into main? (Y=squash, m=merge, n=no): "
    read -r merge_response
    
    case "$merge_response" in
    [yY] | [yY][eE][sS] | "")
        merge_type="squash"
        break
        ;;
    [mM] | [mM][eE][rR][gG][eE])
        merge_type="merge"
        break
        ;;
    [nN] | [nN][oO])
        merge_type="no"
        break
        ;;
    *)
        echo "Please answer Y (squash), m (merge), or n (no)"
        ;;
    esac
done

# Handle merging
if [ "$merge_type" != "no" ]; then
    # Go back to original repo to merge
    cd "$GIT_ROOT"

    # Check if we're on main/master
    current_branch=$(git symbolic-ref --short HEAD)
    if [ "$current_branch" != "main" ] && [ "$current_branch" != "master" ]; then
        # Try to switch to main, fall back to master
        git checkout main 2>/dev/null || git checkout master 2>/dev/null || {
            echo "Error: Could not switch to main/master branch"
            exit 1
        }
    fi

    if [ "$merge_type" = "squash" ]; then
        echo "Squash merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge --squash "$FEATURE_NAME"; then
            # Commit the squashed changes (opens editor)
            if git commit; then
                echo "Squash merge successful!"
                merge_successful=true
            else
                echo "Commit cancelled or failed."
                echo "Worktree preserved at: $WORKTREE_DIR"
                echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
                exit 1
            fi
        else
            echo "Squash merge conflicts detected. Please resolve them manually."
            echo "Worktree preserved at: $WORKTREE_DIR"
            echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
            exit 1
        fi
    else
        echo "Merging '$FEATURE_NAME' into $(git symbolic-ref --short HEAD)..."
        if git merge "$FEATURE_NAME"; then
            echo "Merge successful!"
            merge_successful=true
        else
            echo "Merge conflicts detected. Please resolve them manually."
            echo "Worktree preserved at: $WORKTREE_DIR"
            echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
            exit 1
        fi
    fi

    # Automatic cleanup after successful merge
    # Check for unstaged changes in the worktree
    cd "$WORKTREE_DIR"
    if ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
        echo "Warning: The worktree has unstaged changes, staged changes, or untracked files."
        git status --short
        
        while true; do
            printf "Force remove the worktree anyway? (y/N): "
            read -r force_response
            
            case "$force_response" in
            [yY] | [yY][eE][sS])
                force_remove=true
                break
                ;;
            [nN] | [nN][oO] | "")
                echo "Worktree preserved at: $WORKTREE_DIR"
                echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
                exit 0
                ;;
            *)
                echo "Please answer y(es) or n(o)"
                ;;
            esac
        done
    fi

    # Go back to original repo for cleanup
    cd "$GIT_ROOT"

    # Delete the branch
    echo "Deleting branch '$FEATURE_NAME'..."
    git branch -d "$FEATURE_NAME"

    # Remove the worktree
    echo "Removing worktree at '$WORKTREE_DIR'..."
    if [ "$force_remove" = true ]; then
        git worktree remove --force "$WORKTREE_DIR"
    else
        git worktree remove "$WORKTREE_DIR"
    fi

    echo "Cleanup complete!"
else
    echo "Skipping merge."
    
    # Ask about cleanup only if no merge
    while true; do
        printf "Do you want to delete the worktree and branch '$FEATURE_NAME'? (y/N): "
        read -r cleanup_response
        
        case "$cleanup_response" in
        [yY] | [yY][eE][sS])
            cleanup_response="y"
            break
            ;;
        [nN] | [nN][oO] | "")
            cleanup_response="n"
            break
            ;;
        *)
            echo "Please answer y(es) or n(o)"
            ;;
        esac
    done

    # Handle cleanup
    if [ "$cleanup_response" = "y" ]; then
        # Check for unstaged changes in the worktree
        cd "$WORKTREE_DIR"
        if ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
            echo "Warning: The worktree has unstaged changes, staged changes, or untracked files."
            git status --short
            
            while true; do
                printf "Force remove the worktree anyway? (y/N): "
                read -r force_response
                
                case "$force_response" in
                [yY] | [yY][eE][sS])
                    force_remove=true
                    break
                    ;;
                [nN] | [nN][oO] | "")
                    echo "Worktree preserved at: $WORKTREE_DIR"
                    echo "To clean up later: git worktree remove '$WORKTREE_DIR'"
                    exit 0
                    ;;
                *)
                    echo "Please answer y(es) or n(o)"
                    ;;
                esac
            done
        fi

        # Go back to original repo for cleanup
        cd "$GIT_ROOT"

        # Remove the worktree
        echo "Removing worktree at '$WORKTREE_DIR'..."
        if [ "$force_remove" = true ]; then
            git worktree remove --force "$WORKTREE_DIR"
        else
            git worktree remove "$WORKTREE_DIR"
        fi

        echo "Cleanup complete!"
    else
        echo "Worktree preserved at: $WORKTREE_DIR"
        echo "To merge later: git merge '$FEATURE_NAME'"
        echo "To clean up later: git worktree remove '$WORKTREE_DIR' && git branch -d '$FEATURE_NAME'"
    fi
fi
